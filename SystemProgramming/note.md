시스템 프로그래밍
========

> 3월 3일

* 컴구의 내용을 알아야 수업을 할수있음

### Introducing Computer Systems from a Programmer's Perspective

- Randal E. Bryant, David R. O'Hallaron
- Computer Science and Electrical Engineering
- Carnegie Mellon University

### Outline

Introduction to Computer Systems

* Course taught at CMU since Fall, 1998

학생들에게 무엇을 제일 먼저 가르쳐야 하는가? 어떤 언어를 가르치는것이 제일
좋은것인가? 지난 30년동안 제일 싸워가면서 굉장히 많이 바뀌어왔다. 지금은 좀
먼지가 가라앉은것같은데 여전히 ㄱ싸우긴함. 지금 두가지 진영이 있는데, 한 진영은
우리학교처럼 C를 먼저 가르치는 긴영, 한 진영은 카이스트처럼 파이썬을 먼저
가르치는 진영. 이건 중국집악서 짜장면 짬뽕가은 둘다 장단이 있고 정답은 없음.
가장 기본적인 프로그래밍이라는것을 배웠다고 치면, 헬로월드는 쓸수 있다고 치고,
이제 시간이 지나면 그 다음엔 컴퓨터 시스템이라는게 어떻게 생겼는지. 컴퓨터가
뭐하는거냐는 대부분 알고있는데, 컴퓨터 시스템이라는건 뭐냐. 이 속에 뭐가
들어있어서 이러한 일을 할 수 있게 하는건가. 컴퓨터 시스템이라는걸 어떻게
가르칠거냐.

제일 좋은 생각은 컴퓨터를 뜯어서 보여주는것. CPU는 이렇게 생겼다. 그래픽카드는
이렇게 새겼다. 각자가 하는일을 설명해주고. 더 나아가서는 뚜껑을 열어서
안에있는걸 보여주는게 더 나은데 CPU를 열어준다고 이게 뭐가 보이나? 확대경을
가져와서 보여줘동 ㅏ무것도 안보이는데.노트북 데스크탑은 눈에 보이는데 이속에서
무슨일이 일어나는지는 알수가 업다. 블랙박스 처럼. 이 속에서 무슨일이
일어나는지를 가르쳐보자 하는것이 바로 이 **책**이다. 단, 컴퓨터를 만드는 사람읭
ㅣㅂ장이 아니라 컴퓨터 프로그램을 프로그래킹 하는 프로그래머의 입장에서 짜는것.
내가 프로그래머가 아니고 뭐 한글가지고 웹서핑하고 이런일이나 하면 이게 필요가
없다. 하지만 프로그램을 만들어서 커다랑 시스템을 만든다 하면 바로 이걸
배워야된다 이거임.

### Computer Arithmetic

*Builder's Perspective*

컴퓨터를 만드는사람의 입장에서 봤을떄엔 얘네는 계싼을 하는 회로가 컴퓨터를
이루는 근간. 게이트를 만들어서 어떻게 신호가 빠르게 움직이게 하는지. 윗쪽에서
시그날이 오면 어떻게 아웃풋이 나가는지. 전자가 움직이는 속도는 정해져있으니
중간에 거쳐가는 게이트가 몇개가 있는지에 따라 시간이 결정되겠지? 게이트가 두개면
2, 게이트가 열개면 10, 이러한 서킷을 디자인하는사람들은 어떻게하면 이 DEpth를
어떻게 낮출수 있는지, 열개까지 거치지 않고 한두개만 통과하게 할지, 혹은 이
게이트 서킷 하나하나의 시간을 ㅈㄹ이는것이 목표. 내가 컴퓨터를 만드는사람이면
이것이 목표

*Programmer's Perspective*

프로그래머의 입장에선 이제 저 전자회로는 별 상관이 없다. 프로그래머 입자에선
그냥 프로그램을 짜ㅈㅆ을떄 결과가 나오고 잘 돌아가면 되는거야. 이 컴퓨터라는건
이런 프로그램을 만들어서 집어넣으면 돌아가면서 아웃풋이 나오는것이 컴퓨터가
이것이 바로 프로그래머가 알고잇는 전부죠.

(예제를 보여줌) 이렇게 이런 프로그램을 짰으면 엑스가
오부터 오십, 오백만까지 쭉 늘어나면서 제곱을 하면서 프린트할텐데, 이것을 과연
돌리면 어떤일이 일어나느냐 (인티저 오버플로우) 여기까지는 내가 무슨짓을 했는지
알수있겠는데 여기선 왜 갑자기 이게 음수가 되고, 이 다음엔 왜 갑자기 양수가 되고
이 다음부턴 무슨일이 일어나느냐? 이건 내가 원하는 결과가 아니잖아. 여기까지는
0이 두개씩 붙었고 그 다음도 0이 두개 붙는데, 이 다음은 왜 내가 원하는 결과가
안나오는가? 이런이리 발생하면 컴퓨터를 어떠ㄱㅎ게 해야하는가? 컴퓨터를 갔다
버려야죠? 근데 이럴떄마다 컴퓨터를 버리면 작동하는 컴퓨터가 거의 없을ㄷ텐데
어떡해. 내가 원하는거랑 실제 결과가 다르면 어떻게 해야한ㄴ가? 프로그래머
입장에선 내가 안에 어떤 서킷이 있는지 아무것도 몰라. 내가 프로그램을 하지만
여기서 어떤일이 일어나고있는지 아무것도 몰라, 이런걸 할수있는것엔 한계가 있다.

이제 여러분한테 원하는건 이런일이 일어나지 않기 위해선 컴퓨터 시스템이 어떻게
돌아가는건지 좀 알려줘야겠다 이런거야. 만약 숫자를 손으로 쓴다고 하면 자릿수에
제한이 없지만 컴퓨터가 가지고 계산을 할수있는 숫자는 **Word**로 제한이 되어있다.
일정한 크기가 넘어가면 이쪽에 있는 비트들은 없어져버리는거야. 그거를 왜
위에있는걸 버리나? 밑에있는걸 버리면 더 좋을텐데? 혹은 왜 정수오버플로우가
일어나면 왜 컴퓨터가 말을 안해주나?

이제 이런일을 막기위해서 부동소수점 연산도 나왔다. 이러면 어느정도는 내가 원하는
결과를 얻을수있지. 그런걸 만들기위해선 밑에 돌아가는 원리를 알아야한다

### Memory System

*Builder's Perspective*

CPU, 레지스터, L1 data-cache, L1 instruction-cache, L2 unified cache, RAM, Disk

i-cache라는건 내가 다음에 실행할 명령어가 무엇인지 미리 저장해놓은것, 데이타
캐쉬는 내가 어떤걸 읽어서 어떤걸 쓸건지가 저장된것이 데이타 캐쉬.

보통 L1캐쉬는 자기혼자쓰고, 보통 L2캐쉬는 2~4개 코어가 같이 쓰더라. 그리고
L1에선 d캐쉬 i캐쉬가 따로있지만 L2에선 구분없이 같이쓰더라. 여기까진 L2밖에
없지만 이제 L3, L4가 있기도 하더라. 그리고 요즘은 디스크가 없이 SSD가 있는경우도
있더라. 이제 이런건 컴퓨터를 만드는사람의 입장. CPU는 얼마나 좋아야 하는가,
캐쉬와 램은 얼마나 커야하는지, Disk는 하드를 달건지 NAND Flash를 달건지 등등
여러가지를 결정해야한다. 캐쉬도 **라이트백 캐쉬, 라이트 스루 캐쉬**, **다이렉트
맵드, 인덱스드**, 메모리도 **동기, 비동기**, **가상 인덱싱, 피지컬 인덱싱** 등등
고려할게 많다.

*Programmer's Perspective*

프로그래머 입장에선 CPU가 있고 내가 쓸수있는 메모리가 얼마냐가 중요하죠. 근데
그렇다고 이제 내가 L1 L2 RAM 이런걸 다 몰라도 되느냐. 사실 이걸 안다고
도움된다고 생각되지 않을수도 있다. 하지만 이제 이걸 봐라.

(캐쉬 프렌들리한 프로그램 짜는 예시)

똑같이 2048*2048 매트릭스를 카피를 해도 row-wise로 카피하는거랑 column-wise하게
카피하는게 전혀 성능이 다르지않는가. (i7 2.7GHz에서 실험했을때 30배 느려짐) 이게
성능이 전혀 똑같다면 내가 메모리 구조를 전혀 신경 안써도 되겠지? 하지만 현실은
그리 녹록치 않다.

이제 이런걸 알면 내가 액세스하는 메모리는 다 똑같은데, 액세스 하는 방법에 따라
속도가 달라지는걸 볼수있다. 이렇게 속도차이가 많이나면 속에서 뭔가 메모리를
단순히 액세스하는거 외에 뭔가 한다는걸 알수있다 (캐싱). 이 숫자를 한번 줄여보자.
2048이 아니라 100, 200, 300, 400 등등 크기를 바꿔가며 또 해보자. 어떤 차이가
있을까? (캐시 바운더리)

결국 저 하드웨어 사이즈를 알수밖에 없다. 저 L1 데이터캐쉬 사이즈가 얼마인지.
L2로 가면 느려지지. L3로 가면 더 느려지고 RAM으로 가면 더더욱 느려지겠지. 지금
이 램이라는건 우리는 마치 이차배열을 이차원공간처럼 쓰지만 사실 이건 선형이다.
내가 이걸 row-wise로 하면 선형으로 쭉 읽겠지만 column-wise로 하면 내가 이 선형
메모리를 전체를 계속 훑겠지. 자 이럴때 보통 캐쉬는 한번 이곳을 읽으면 그 근처를
64바이트를 통쨰로 읽고, 쓸떄도 똑같이 한다. 이떄 여기서 전체를 계속 stride로 훑으면
중요한 memory bandwidth를 낭비하는거지. 이 현상이 왜 일어나느지, 어떻게
해결하는지를 알으려면 결국 이 메모리 하드웨어 구조를 알아야하는거야.

### 첫번쨰 숙제

앞으로 학생들이 주로 사용할 컴퓨터를 하나씩 정하세요. 그 다음에, 그 컴퓨터를
사용해서 방금 비슷한 프로그램을 짜서 (cache 프렌들리 예제) 이런식으로 버전을
두개 짜서 i j 순서가 다른것이 영향을 주는 예제를 짜봐. 이걸 실제로 크기를
바꿔가면서 해보면 L1~L2, L2~L3, L3~RAM 사이의 간격을 볼수있어. (계단식 그래프를
그림) 이걸 하나 그려보는게 첫번째 숙제다.

여러분들 종강할때 어느정도 레벨이 되려면 이 계산 돌리는걸 직접 하지말고 스크립트
짜서 자동화하세요. 이걸 그려보면 여러분의 캐쉬 사이즈가 대충 어느정도인지
가늠할수있을거야. 그리고 여러분 컴퓨터 스펙이랑 비교해서 얼마나 들어맞았는지
비교해봐.

굉장히 복잡하게 들리지만 사실 그렇지 않아. 여러분 컴퓨터가 너무 일을 많이해서
불쌍하다 싶으면 캐쉬 바운더리 근처만 돌려봐.

**다음주 화요일 실습시간까지**

### Memory Mountain

이쪽은 메모리 크기고, 이쪽은 메모리 스트라이드. 높이는 스루풋 (초당 얼마나 많이
읽느냐). 여러분이 숙제 1을 하면 이 메모리 마운틴을 그려볼수 있는거야. 그러면 L1
L2 크기가 얼마나 되는지 미루어 짐작할수 있겠지.

### Lecture Coverage

* Data representation
* IA32 & x86-64 asm
* Program optimization
* Memory Hierarchy
* Linking
  * With DLL
* Exceptional Control Flow
* Virtual Memory
* Application level concurrency
* I/O and network programming

### Labs

* Key teaching insight:
  * Cool labs => Great Course
* A set of 1 and 2 week labs define the course.
* 1~2주에 랩 하나씩 할거다.

1. Data lab
1. Bomb lab
1. Buffer lab
1. Performance lab
1. Shell lab
1. Malloc lab
1. Proxy lab

### Architecture

* Y86 명령어셋을 다 알아야한다 (간단한 IA32)
