# ncopy.ys - Copy a src block of len ints to dst.
# Return the number of positive ints (>0) contained in src.
#
# 2013-11392 김지현
#
# 먼저, ncopy 함수는 스택프레임에 저장해야할정도로 많은 지역변수를 쓰지 않는다.
# y86은 calling convention은 callee가 스택을 쌓고 정리하며, callee의 함수 스택이
# 별도로 필요하지 않은경우 "스택을 쌓지 않아도 된다"는 것이 이러한 정책의
# 장점이다. 지금 이 문제는 이러한 장점을 살릴 수 있는 경우이므로, 스택을 쌓고
# 정리하는 코드를 지우고, 함수 파라미터(src, len, dst)를 얻어오는 코드를 %ebp가
# 아니라 %esp 기준이 되도록 수정한다. %esi, %ebx, %edi 레지스터를 저장해줘야
# 하므로 12바이트가 쓰이고, 함수가 호출될때 스택에 return address가
# 저장될것이므로, 파라미터들은 %esp에서 16, 20, 24바이트 떨어진곳에 있다.
#
# 그리고 FLAGS를 재활용하지않고 쓸데없이 리셋시켜서 계산을 한번 더 하게 하는
# 코드를 최적화시키고, 거의 필수적인 명령어인 `iaddl`을 구현하였다.
#
# 그리고 한번에 8개씩 검사하도록 Loop unrolling을 하였다


ncopy:
# Prologue
  pushl     %edi # Save callee-save regs
  pushl     %esi
  pushl     %ebx
  mrmovl    24(%esp), %edx # len
  mrmovl    16(%esp), %ecx # src
  mrmovl    20(%esp), %ebx # dst

# Body
  xorl      %edi, %edi # count = 0;
  andl      %edx, %edx # if (len > 0) is true
  jg        Start # Start loop
  jmp       Done # Otherwise, done

# Loop 0
Loop:
  mrmovl    4(%ecx), %esi
  xorl      %eax, %eax
  andl      %esi, %esi
  jle       N0
  iaddl     $1, %edi
N0:
  rmmovl    %esi, 4(%ebx)
  iaddl     $-1, %edx
  je        Done

# Loop 1
  mrmovl    8(%ecx), %esi
  xorl      %eax, %eax
  andl      %esi, %esi
  jle       N1
  iaddl     $1, %edi
N1:
  rmmovl    %esi, 8(%ebx)
  iaddl     $-1, %edx
  je        Done

# Loop 2
  mrmovl    12(%ecx), %esi
  xorl      %eax, %eax
  andl      %esi, %esi
  jle       N2
  iaddl     $1, %edi
N2:
  rmmovl    %esi, 12(%ebx)
  iaddl     $-1, %edx
  je        Done

# Loop 3
  mrmovl    16(%ecx), %esi
  xorl      %eax, %eax
  andl      %esi, %esi
  jle       N3
  iaddl     $1, %edi
N3:
  rmmovl    %esi, 16(%ebx)
  iaddl     $-1, %edx
  je        Done

# Loop 4
  mrmovl    20(%ecx), %esi
  xorl      %eax, %eax
  andl      %esi, %esi
  jle       N4
  iaddl     $1, %edi
N4:
  rmmovl    %esi, 20(%ebx)
  iaddl     $-1, %edx
  je        Done

# Loop 5
  mrmovl    24(%ecx), %esi
  xorl      %eax, %eax
  andl      %esi, %esi
  jle       N5
  iaddl     $1, %edi
N5:
  rmmovl    %esi, 24(%ebx)
  iaddl     $-1, %edx
  je        Done

# Loop 6
  mrmovl    28(%ecx), %esi
  xorl      %eax, %eax
  andl      %esi, %esi
  jle       N6
  iaddl     $1, %edi
N6:
  rmmovl    %esi, 28(%ebx)
  iaddl     $-1, %edx
  je        Done

  iaddl     $32, %ecx
  iaddl     $32, %ebx

# Loop 7
Start:
  mrmovl    (%ecx), %esi
  xorl      %eax, %eax
  andl      %esi, %esi
  jle       N7
  iaddl     $1, %edi
N7:
  rmmovl    %esi, (%ebx)
  iaddl     $-1, %edx
  jne       Loop
Done:

  rrmovl    %edi, %eax

# Epilogue
  popl      %ebx
  popl      %esi
  popl      %edi
  ret
End: # don't remove

# TODO
# 왜 계속 xorl eax eax 하는거임
