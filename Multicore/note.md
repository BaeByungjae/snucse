> 3월 4일

### Memory Wall

메모리 성능은 1년에 10%정도밖에 향상이 안됨. 그래서 60년대 말에 Cache라는
해결방법이 나옴, 아주 잘 쓰이고 있음.

연구를 하기위해서는 Practical 한 솔루션을 제시해야돼요.

멀티코어가 나오고 나서는 캐쉬 구조가 달라짐. ILP Wall과 파워 장벽은
멀티코어로극복했지만, 메모리 장벽은 멀티코어로 극복하지 못했지만 클락이 더
빨라지진 않을테니 오케이

### Programming wall

코어의 갯수가 늘어나도 프로그램이 바뀌지 않으면 의미가 없음.

멀티코어의 성능을 충분히 이끌어내려면 소프트웨어를 잘 병렬화시켜서 만들어야함.

멀티코어 붐이 일었을때 수많은 회사들이 있었지만 이제 IBM, SGI 밖에 안남음. 이
회사들이 왜 다 망했느냐? 몇십억짜리 시스템을 다 사놔도 프로그래머를 뽑기가
힘들어. 그래서 다 고철덩어리가 되는거야. 이게 지금까지의 문제

이게 굉장한 난제이다. 어떻게하면 이 장벽을 뛰어넘을 수 있을까?

### Programming model

응용프로그램을 개발할때 프로그래머와 병렬 컴퓨터 간의 인터페이스

여러분들이 프로그래밍 할때 하드웨어보고 하는거 아니잖아. 어떤 가상의 머신 위에서
하잖아? 그게 바로 프로그래밍 모델. 근데 우리 ILP Wall 전력장벽 해결 왜한겨?
성능해결하려고 한거지? 쉽게 프로그래밍 하게만들겠다고 성능을 잃어선 되겠느냐?
안됌. 근데 알다시피 쉽게 만드는거랑 성능을 최적화하는거는 서로 상충해. 쉽게
만드려면 추상화가 많이 필요하거든.

### 병렬 프로그래밍 모델의 종류

* 셰어드 메모리 패러렐 프로그래밍 모델
  - 오픈엠피
  - 피쓰레드
* 메세지 패싱 페러렐 프로그래밍 모델
  - MPI
* 엑셀러레이터 프로그래밍 모델
  - OpenCL
  - SnuCL
  - CUDA
  - OpenMP, OpenACC
* 옛 프로그래밍 모델에 안주하려는 경향이 있는 사용자를 기술발전의 추세에 맞게
    교육하는것이 중요

OpenMP는 굉장히 쉽게 만들어져있지만 실제로 써보면 성능최적화 이끌기 힘들어. 내가
직접 다룰수있는 여지가 적거든. 메세지패싱에선 MPI가 de facto 표준. 성능도
엄청나게 좋고 클러스터에 쓰기 적합하다. 그리고 이제는 Practical하게 쓰이는
가속기에 쓰이는 프로그래밍 모델들.

SnuCL은 OpenCL의 클러스터버전 내(이재진 교수님)가 만들었당. OpenMP 4.0은
엄청나게 많은 회사들이 밀고있고, OpenACC는 네개의 큰 회사가 밀고있다. OpenACC
한번 써봐요 얘 성능이 하나도 안나와. OpenMP는 미국 국립연구소 (로렌스랩,
등등)에서 써서 스탠더드가 됨. 근데 OpenMP 4.0은 스펙만 있고 구현체가 없어 (?)
3~4개월 안에 나옴. CUDA는 많이 쓰죠. 이게 제일 먼저 나옴. CUDA는 엔비디아 사유
프로그램이라 아무나 구현체를 못만듬. 그래서 OpenCL이 거기에 대항해서 나옴.
OpenCL은 GPU 안가리고 다 돌아가는데 CUDA는 엔비디아에만 들어감. 삼성 타이젠 삼성
시계에 들어가는 OpenCL 구현체 우리가 만든거임. OpenCL 로고도 애플이 가지고있음.
애플이 OpenCL 밀고 내부적으로 많이 사용하고있음. 지금 AMD, Intel이 많이
밀고있다. Intel과 nVidia은 원수간의 원수. 요즘 게임할떄 아니면 그래픽카드 써요?
온보드 그래픽카드 사요? 그거 다 CPU 안에 들어있는거. 인텔이랑 AMD가 APU 만들어서
엔비디아가 시장을 많이 잃었어. 그래서 예전에 인텔에서 논문 많이 쓰면 엔비디아
이름도 많이 나오고 그랬는데 요즘은 논문에서 엔비디아 상호도 못쓰게한다.

실제로 기술이 발전을 하면 뭐해? 사용자들이 배우기를 해야지. 옛날거에 안주하면
안돼. 프로그래밍 장벽을 극복하기위해 노력을 하자.

### 본 과목에서 다루는 주제

* 순차컴퓨터 시스템의 구조 및 소프트웨어의 동작원리
* 병렬성
* 병렬 컴퓨터 시스템의 구조 및 소프트웨어의 동작원리
* 가속기의 구조
* 병렬화, 벡터화, 동기화 방법
* 메모리 계층구조에 대한 최적화, 루프 최적화, 기타 최적화
* Ptheads
* OpenMP
* MPI
* OpenCL
* CUDA
* SnuCL

맨처음에 컴퓨터 파워 온 하면 어떤동작이 일어나나? 컴구나 시프나 오에스에서
안배웠나.

여러분 OS에서 베컨트 알고리즘, 데이컨트 알고리즘 배웠죠. 그거 텍스트북 틀렸어요.
그거 돌려봐. 안돌아가. **지금 세상에 나와있는 OS책 다 틀렸어.** 지금 멀티코어
아키텍처에서 그거 돌리면 그거 다 안돌아가. 상호배제할때 쓰는 동기화 방법 그거
실제로 C로 임플리먼트해서 돌려봐. 메모리 컨시스턴시 고려를 안하면 안돌아가.
그런것들 실제로 안되는거 이세상에 아는사람 몇명 안될거야. 30년전에나 잘되던
방법이야.

멀티코어에서도 캐쉬를 잘 다루는거 중요해요. nVidia 2007년도에 CEO가 서울대
방문한거 알아요? 좋은사람같던데 왜그러나 모르겠어. 아무리 회사라도
아카데믹한곳에선 그런짓 하면 안돼.

SnuCL은 OpenCL 같은 스펙에, 클러스터 위에서 돌릴 수 있도록 만든 새 구현체.
코딩을 새로 할 필요가 없다. AMD에서도 홍보해준다.

> Lecture 2

컴퓨터와 기수법
--------

### 컴퓨터

계산기. 내부 구조가 아주 복잡. 보통 블랙박스로 추상화. 추상화라는건 이제 우리가
관심없는건 신경안쓰고 관심있는 특성만 보자.

### 데이터

사전적 정의: 추론 논의, 계산의 기반이 되는 측정이나 통계에 의해 얻어진 사실적
정보

컴퓨터공학에선? 컴퓨터로 처리할 수 있는 형태로 구성된 사실적 정보

요즘 빅데이터 유행하지? 빅데이터에서 중요한게 뭘까. 빅데이터엔 중요한 세가지
특정이 있어요. 3V, 볼륨, 버라이어티, 벨로시티. 이게 중요해. 중요한건 분석방법.
통계를 이용해서 분석하지. 새로운 분석방법은 뭐 소셜베이스 외엔 별로 없고. 이건
새로운게 하나도 없는데 그냥 포장만 새로 한거야.

우리나라에서 빅데이터라고 할만한게 얼마나 많을까? 엑셀에 안들어가면 빅데이터라고
쳐봐. 엑셀에 16만로우까지 안들어가. 우리나라 전국민 건강보험 데이터가
300메가밖에 안돼. 이So

중요한건 데이터가 큰것보다 빠르게 처리하는거야. 데이터가 아무리 많아도
처리하는데에 한달이 걸리면 뭐하나? 처리하는동안 데이터 가치가 다날아가. 이걸
어떻게 빠르게 처리하느냐? 멀티코어야.

### 0과 1을 나타내는 전기신호

명확히 구분되는 두가지의 서로 다른 상태: 0과 1. 0.1볼트 근처는 0, 5볼트 근처는
1. 노이즈가 있어도 쓸 수 있도록.

### 하드웨어와 소프트웨어

* 하드웨어
  - 컴퓨터 시스템의 물리적 구성요소
* 소프트웨어
  - 여러개의 프로그램으로 구성된 집합
* 프로그램
  - 주어진 입력을 가지고 원하는 출력을 얻기위해 무엇을 해야하는지 컴퓨터에게
      지시하여 컴퓨터를 동작시키는 역할을 함

### 순차 컴퓨터 시스템

* 우리가 흔히 알고있는 시스템. 패러렐과 비교하여 이야기할떄 사용하는 용어.
* 하드웨어, OS, 어플리케이션 크게 세 요소로 추상화됨

### Application

* 응용소프트웨어. 줄여서 응용(어플)이라고 부름
* 사용자가 특별한 작업을 수행할때 도움을 주는 음용 프로그램의 집합

### 시스템 소프트웨어

컴퓨터 하드웨어를 운용하고 응용 소프트웨어를 실행하기위한 플랫폼.

ex) OS, CLI, Windows, Compiler, Debugger

### 유틸리티 소프트웨어

시스템 소프트웨어의 일종

컴퓨터 하드웨어와 소프트웨어를 관리하고 튜닝할떄 이용

ex) 백신, 압축프로그램, 파티셔너, 모니터, 어셈블러

얘네는 다 구분이 모호하다. 엄격하게 구분 못지어. 이거 구분하고있는놈들은
할짓없는 놈들이야

### r-진법

위치기반 기수법 (positional number system)

수는 숫자들을 연이어 나열한것으로 표현, 그 표현이 가지는 값은 각 숫자가 가지는
값을 더한것. 각 숫자의 값은 숫자의 위치에 따른 무게값에 따라 결정됨.

소숫점 (radix point)

수라는 개념은 절대적이야. 십진법, 십육진법 이런건 우리가 그 수를 표현하기위해
만든것들일 뿐이야.

### 흔히 사용하는 기수법의 기수와 숫자

이진법
팔진법
십진법
십육진법

여러분 팔진법은 요즘 잘 안쓰죠? 그리고 십육진법은 숫자가 모자라니까 알파벳 (A,
B, C, D, E, F) 을 쓰지.

기수법은 별로 안좋은게 이진수, 십진수, 팔진수 다 같은 숫자 (digit)을 써서 문맥에
따라 모호할떄가 있어. 이럴땐 명확하게 해주지

### Fixed-point repr

소수점이 어떤 위치에 고정되어있다고 가정. 소수점을 컴퓨터 내부에서 표시할 필요가
없음.

### 진수변환

이진수 -> 팔진수, 이진수 -> 16진수는 그냥 세개 네개씩 묶으면 된다.

### 십진 정수 N을 이진 정수로 변환하는 방법
### 십진 소수 N을 이진 소수로 변환하는 방법

### 정수부와 소수부가 조합되어있는경우

각부분을 따로 변환해서 결과를 조합

### 십진수를 8/16진수로 변환하기

십진수를 이진수로 바꾸고, 그걸 8/16진수로 변환.

### Unsigned integer

이진수가 0이나 양의 값을 나타낼 때.

n비트 언사인드 인티저 x의 범위: [0, 2**n)

### Signed integer

부호 붙은 수를 n개의 비트로 인코딩하는 방버

1.  부호붙은 크기 표현
1.  1의 보수
1.  2의 보수
    * 하드웨어 구현이 제일 간단함. 대부분의 컴퓨터가 사용중

옛날엔 1의보수, 부호붙은 크기를 다 썼지만 2의 보수가 제일 좋다. 제일 간단하다 =
트랜지스터가 적다 = 빠르다, 그 공간에 다른일을 할 수 있다.

### 보수

r진법으로 표현된 n개자리수 x의 r의 보수(radix complement, complement) 는

r**n - x (if x != 0)
0        (otherwise)

x의 (r-1)의 보수(diminished radix complement) x` 는

x` = r**(n - 1) - x;

### 보수 구하기

십진수 836의 (10 - 1)의 보수는 10**3 - 1 - 836 = 999 - 836 = 163

이거 쉬운 계산은 그냥 각 자리수를 (r-1) 에서 빼서 다시 조립하면 됨.

x가 0이 아닌경우, x의 (r-1)의 보수에 1을 더하면 x의 r의 보수를 얻을수있음

### 1의 보수 표현 === (2-1)의 보수

r=2일 경우에, (r-1)의 보수를 사용하여 음수를 표현하는것.

ex) 6의 b1의 보수는 (2**4 - 1) - 6 = 15 - 6 = 9
9는 b1001이고 (2-1)의 보수 표현에서 -6을 나타냄
2**3 을 안쓰는데엔 이유가 있음

MSB는 부호비트
1이면 음수, 0이면 양수

단점. 0을 표현하는 방법이 두개가됨.

0000 = +0
1111 = -0

### 2의 보수 표현

현재 대부분의 컴퓨터가 사용중

n비트 이진수로 표현되는 정수 x의 2의 보수

### 2의 보수 표현의 범위와 값

[-2**(n-1), 2**(n-1) - 1]

### (피피티 참고, 도저히 타자로 못치겠는 슬라이드. 피피티 볼것)

### Modular arithmetic, clock arithmetic

Euclidean algorith

두 정수 m과 n(!=0)이 주어졌을때, m = qn + r, (0<=r<|n|) 을 만족하는 유일한 정수
q와 r이 항상 존재함.

이게 우리가 아는 나눗셈하고 어떻게 다르냐? 음수일경우 다름

일반적인 경우: -7을 3으로 나누면 몫은 -2, 나머지는 -1
유클리디안: -7을 3으로 나누면 몫은 -3, 나머지는 2 (항상 양수여야하니까)

### mod

q := floor(x/m), m != 0

r = x mode m = x - mq, m != 0

m은 modulus 라고 불림

*   앞으로 이용할 성질

    ```
    (a+b) mod n = ((a mod n) + (b mod n)) mod n
    ```

보통사람들이 말하는 소프트웨어는 소프트웨어가 아니에요. 그건 SI야. 그건
전공불문이야 아무나 가서 하면 돼. 그건 컴퓨터과학이 필요하지 않아. 그건
소프트웨어 하는게 아냐. 그건 용역하는거야. 컴퓨터공학 하는데에 필요없는것들.
그건 대단할 놀러지가 필요하지 않아.

### 합동관계 (congruence relation)

나머지가 같으면 합동이다.

### 모듈로-m 연산 (modulo-m operation)

모듈러스가 m인 합동관계를 이용한 연산

m개의 수 0, 1, 2, .. , m - 1을 연산에 이용

예) 모듈로-8 덧셈

1 + 4 === 5 (mod 8)
8 + 5 === 5 (mod 8)
7 + 3 === 2 (mod 8)
0 + 8 === 0 (mod 8)

내가 오늘한것들은 중학생한테 가르쳐도 다 할거야. 중요한건 이 숨은뜻을
이해하는거야.

--------

Lecture 03

부울 대수와 조합 논리회로
--------

*   1854년, George Boole
*   두개의 원소를 가진 집합 {0, 1} 을 정의하고, 이 집합에 대해 정의된 세
    논리연산 AND, OR, NOT 을 만듬
*   클라우드 섀넌의 논문에 베이스를 두고있음. 이때 섀년이 쓴 Information
    Theory가 지금 컴퓨터의 근간을 이룸.

### 부울 식

상수 0과 1, 변수, 논리연산자 and or not 을 포함하는 심볼들로 구성된 문자열.
부울식은 귀납적으로 정의됨

1. 심볼은 부울식
1. exp가 부울식이면 ~exp 도 부울식
1. e1, e2가 부울식이면 (e1 && e2), (e1 || e2) 도 부울식

### 곱셈항과 민텀

*   term, 항

    불 식에서 `+` 로 나뉜 각 부분을 항이라고 함

*   literal, 리터럴

    부울 식에 나타나는 변수 자체 (x)나 변수의 부정 (~x)

*   product term, 곱셈항

    리터럴의 AND 연산만으로 구성되어있는 항

*   minterm, 민텀

    n개의 변수를 가진 부울 식에서 각 변수에 대한 리터럴이 '한번씩만' 나타나는
    곱셈항. 한번씩 다 나와야됨

    예를들어 x, y 두 변수에 대해 나올수있는 모든 민텀은

    - ~x * ~y
    - ~x * y
    - x * y
    - x * y

### 부울 대수의 공리, Axiom

Axiom? 무조건 참이라고 믿는 / 가정하는 논리체계의 기반, 바닥.

* 집합 `B = {0, 1}`에 대한 부울 대수는 여섯 개의 공리를 가짐

1.  B에 속한 모든 x와 y에 대하여 x + y 와 x*y 도 B에 속한다.
2.  B에 속한 모든 x에 대해 x + 0 = x, x*1 = x 를 만족하는 서로 다른 원소 0과 1이
존재한다.
3.  B의 속한 모든 x와 y에 대하여 x + y = y + x, x\*y = y*x
4.  배분법칙
5.
6.

### 부울 대수의 정리, Theorem

* 공리를 이용하여 부울 대수에 관한 여러개의 정리를 증명할 수 있음

B에 속한 모든 x, y에 대하여..

1.  x + x = x, x*x = x
2.  x + 1 = 1, x*0 = 0
3.  (x + y)\*x = x, (x*y) + x = x
4.  (x + y) + z = x + (y + z), (x\*y)*z = x\*(y\*z)
5.  ~x 는 유일
6.  ~(~x) = x
7.  ~(x + y) = ~x\*~y, ~(x*y) = ~x + ~y

### 정리 1의 증명

진리표로 증명함.

사실 5번 빼고 다 진리표 쓰면 됨

### 정리 3의 증명

진리표 안쓰고 공리 쓰면 됨

```
  (x + y)*x
= x*(x + y)
= (x + 0)*(x + y)
= x + (0*y)
= x + (y*0)
= x + 0
= x
```

Term rewriting system을 쓰면, 정리 증명을 자동으로 할 수 있다. 프로그램을 짜면
'이 프로그램에서 이 시점은 x는 항상 1이다' 이런것도 Theorem prooving 기계로 함.

### Boolean function

B = {0, 1} 일때, n개의 변수 x1 x2 .. xn 을 가진 부울 식은 부울 함수 f: B^n -> B
를 정의함

n개의 변수를 가진 서로 다른 부울 함수는 총 2^(2^n) 개

### Functional Completness (함수의 완전성)

어떤 논리연산의 집합에 든 연산만으로 서로 다른 모든 부울 함수를 정의할 수 있으면
그 집합은 Functionally Complete 하다고 말함.

* 어떤 불 함수라도 AND, OR, NOT 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 XOR 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 XNOR 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 NOR 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 NAND 의 조합으로 정의할 수 있음

### 진리표를 부울 식으로 변환하기

*   부울 함수를 부울 식으로 쓸수만 있으면 회로로 만드는 과정은 정말 쉽기때문에
    이런 과정이 필요함
*   n개의 리터럴을 가진 민텀과, n개의 변수를 가진 진리표에 존재하는 입력 값의
    조합은 1:1 대응. n개의 변수를 가진 진리표의 한 Cell은 모두 n개의 리터럴을
    가진 민텀으로 표현 가능하다는 이야기
*   민텀은 대응되는 입력 값의 조합에 대해서만 1이 됨.
*   진리표에서 함수의 결과 값이 1이 되는 입력 값의 조합에 대응되는 민텀을 모두
    구하고, 이들을 OR 연산으로 묶으면 진리표를 부울 대수로 만들 수 있음.

* 반 가산기
  * 두개의 입력 비트 x, y를 더하고, 그 결과로 두개의 비트 s와 c를 출력하는
    전자회로

### 부울 식의 간소화

Karnaugh map

### 로직 게이트

부울대수는 논리회로의 수학적 모델링, 로직 게이트는 이것의 물리적인 구현

*   Propagation Delay

    전달 지연

*   게이트 딜레이

    게이트 하나 통과할때마다 1ps정도 작은 딜레이가 생김

    ```
    <@p> 45~65nm에서 온오프 걸리는 시간이 ps
    <@p> 1ㅔㄴ
    <@p> 1ps
    ```

### 기본적인 로직 게이트

이름  | 트랜지스터 수
------|---------
NOT   | 2
OR    | 6
AND   | 6
NOR   | 4
NAND  | 4
XOR   | 14
XNOR  | 12

### 로직 게이트의 함수적 완전성

*   Universal gate

    Universal gate 하나만으로 모든 부울 함수를 구현할 수 있음

### 로직 다이어그램

Schemetic

### Bus

옴니버스에서 나온 말. 동시에 전기신호가 전송되는 두개 이상의 연관된 와이어들로
이루어진 집합. 버스 내 각 와이어가 한 비트의 정보를 전송함

*   Word

    컴퓨터에서 하나의 단위로 취급하여 처리하는 서로 관련된 비트들의 묶음.
    일반적으로 하나의 워드 안에 든 여러개의 비트들을 동시에 처리하도록 컴퓨터
    하드웨어가 구현되어있음

### Tristate buffer

로직게이트는 아니지만 비슷한 역할을 하기때문에 쓰임

함수표(function table)는 진리표를 압축하여 더 간단히 나타낸것

조합 논리회로
--------

Combinational logic circuit

*   로직 게이트들을 와이어로 연결한 회로, 항상 현재의 입력값들에 의해 그 출력
    값이 결정됨.
*   여러개의 입력과 여러개의 출력을 가짐
*   각각의 출력은 하나의 불함수로 표현됨

### 멀티플렉서

*   셀렉터, MUX
*   2^n개의 입력과 n개의 선택 비트가 들어옴, 한개만 선택되어 출력됨
*   2-to-1, 4-to-1, 16-to-1 멀티플렉서

### 디코더

*   Demultiplexer
*   n개의 입력비트에 대해 최대 2^n개의 출력을 가질 수 있음
*   2-to-4, 3-to-8 디코더
*   enable 입력을 가질때도있음

### 디코더를 이용한 MUX 구현

2-to-4 디코더를 이용해 4-to-1 MUX 를 구현할 수 있음

--------

> 3월 11일

조합 논리회로만으로 ALU (기본 계산의 단위) 다 만들수 있음. GPU에도 이 벌겨 아닌
ALU가 수천개씩 들어있음. 하지만 이걸로 메모리는 커버 못함.

순차논리회로는 메모리와 관련이 있음.

책에 그림 자동으로 배치하는 알고리즘이 아직도 난제임

순차 컴퓨터 시스템 제대로 설명하려면 200~300p 나올거임. 그거 하고나면 컨텍스트
스위칭, 컨커런시에 대해 배울거임. 베이컨스 알고리즘 이런거 다 안돌아간다.

컨커런시에 대한 기반이 없으니, 순차컴퓨터 시스템부터 기반을 아주 잘 잡아놔야됨.
근데 이 쉬운 개념을 생각을 안하고 자기것을 못만드니 기본이 안되는거임.

베이컨스 알고리즘 이런거 다 안돌아가요
캐시 끄고해도 안돌아가
논캐시어블 해도 안돌아가
메모리 컨시스턴시가 보장이 안돼서그래
그거 OS 책쓴사람이 몰라서그래

멀티코어시스템을 공부하려면 싱글코어시스템을 잘 알아야돼요
공부하기 얼마나 편해 그지
이것만 보고 배우면 돼요
여러분들은 기니피그여
너 동물이야 아냐
동물이지
포유류 안의 영장류지
knuth

마이크로소프트 워드로 쓴거에요
레이텍으로도 써봤는데
워드가 더 편해요

아래아 한글에서 이미지 프로세싱하는걸 좀 빠르게 해달라고 막 그러고있는데
워드로 쓰고있어요
knuth 이분이 논문 출판할때 마음먹은대로 안돼서 Tex을 개발했어요.
이걸갔다가 쓰기 어려우니까 레이텍이라는걸 만든사람이 Lamport 라는 사람이에요

knuth 이분은 수학관련 논문이면 변하는게 없어요
어떻게 하면 멀티프로세서 시스템에서 여러개의 프로세스가 correct하게 돌아가는
그런걸 이야기한사람이 lamport에요
안돌아간다 이거야
이사람도 이걸 만들어서 사람들을 굉장히 이롭게 했어요
그게 연구에요 연구
연구를 하면 사람에게 practical하게 도움이 되게 해야지

아주 fundamental하게 그런것도 도움이 되는게 많아요
 여러분 물에 대해 얼마나 알아요
 화장품이 뭐냐
 물 + 기름이에요
 왜 이런얘기를 하느냐
 들어보라고 한번
 기름에다가 물을 넣는거하고 물에다가 기름을 넣는거하고
 성질이 달라져요
 이게 뭐겠어요?

기름을 까뜩채워
그리고 여기다가 계면활성제를 넣어요

그리고 물을넣어
그게 여러분 바르는 연고있지?
그거에요

로션같은거는 물에다가 기름활성제를 넣어서 기름을 넣는거야
이게 애멀젼이에요 애멀젼

ㄱㄴ데 왜 이렇게 되는가가 원리가 규명이 안되어있어
그래서 물에다가 기름썪은건 바르면 시원해요
근데 기름에 물 섞은건 바르면 끈

난 이런걸 왜 해봤을까?
그러게요
여러분이 냉각을 하죠
근데 써버를갔다 냉각을 하는데
근데 수냉식으로 쿨링하다가
이거 터지면 어떻게돼요?
정xxxx이가 이거 한순간의 실수로 3000만원 날렸어
물때문에
응?
과냉각을 시키면 어떻게돼요
그러면 공기중에 구름이생겨
그러면 3000만원 날라가는거야
18도 이하로 서버실을 과하게 춥게만들면 안돼
근데 우리는 5도로 했거든

그래서 날라간거야
근데 기름을갔다가 쓰면
기름은 이런 위험이 없는데
열전도성이 5배 나빠요

근데 우리가 기름에다가 물을 섞으면 비전도성이 유지가 되면서 점도가 굉장히 높아지고 열전도성은 물처럼 좋아져

그래서 내가 화학 실험실에 갔다가 이걸 했어
그래서 이게 됐을까 안됐을까
안됐어 (?)
내가 이거 하려고 논문을 많이 읽어서 기계공학과 논문도 많이 읽어봤는데 별거아니더라구
그래서 그냥 기름으로 했어요
기름이 어떤 기름이겠어요?
미네랄 오일이라고
존슨즈 베이비오일
한말에 오만원 주면 사
이거 하면서 실험에 막 얼굴에 발르니까
보습효과가 있어서
피부가 좋아지더라고
음식에도 들어가요
(멀티코어 수업임)
보통은 미네랄오일 있으면 서버를 그냥 거기다가 담궈버리는데
그러면 귀찮아
서버실이 온 기름천지가 된다고
우리가한건 방열판 안에 기름을 흘려서
터져도 문제가 없지
고런 장점이 있지
거의 세계 최초라고 할수있지
(멀티코어 수업임)
내가 이걸 옆 연구소에 많이 홍보했지
이게 많이 좋은데 대신 방열판이 튼튼해야돼
이게 컴퓨터를 잘 몰라도 상식으로 하는거야
연구란게 원래 그래요
옆길로 이야기가 많이 샜네
순차논리회로가 그래서

순차 논리회로
--------

순차논리회로는 클락을 가짐. 현재의 입력값 뿐만 아니라, state를 갖고 이전
입력값에 영향을 받음.

순치 논리회로 = 조합 논리회로 + 메모리

동기 순차 논리회로, 비동기 순차 논리회로로 나뉨

### 클락

일정한 간격으로 rising edge, falling edge가 생김.

### 랫치 & 플립플랍

우리나라 책들이 이게 아주 헷갈리게 써있어.

커뮤니케이션이 반이야.
앞으로 사회 나가면 소통
생각을 한다음에 남한테 설명하는게 반이라고
남 한번 가르쳐봐요 엄청나게 공부 많이해야돼

메모리는 보통 플립플랍으로 구현됨.

*   하나의 플립플랍은 한개의 비트를 저장
    * 두개의 구분 가능한 상태
*   플립플랍은 보통 랫치로 구현함
    * ..

**플립플랍과 랫치의 차이**

### SR Latch

두개의 입력 Set과 Reset, 두개의 출력 Q와 Q\`

`S = 1 && R = 1` 이 아닌이상 항상 `Q\` = ~Q` 를 만족함

S | R | Q
--|---|---
0 | 0 | Q_prev
0 | 1 | 0
1 | 0 | 1
1 | 1 | *undefined*

`S = 1 && R = 1` 이면, Q가 0과 1로 반복적으로 바뀌는 불안정한 상태에 이름. 허나 그 값이 1이 될지 0이 될지 예측할 수 없음

이걸로 1 비트를 저장할 수 있음

### D Latch

데이터를 지정하는 입력 D

새로운 입력을 받아들일지 말지를 제어하는 입력 C

C = 1 일동안 랫치의 출력이 입력 D에 따라 바로 바뀜

No undefined state

C | D | Q
--|---|---
0 | X | Q_prev
1 | 0 | 0
1 | 1 | 1

### D 플립플랍

D 랫치 두개를 달고, 클락을 달아줌. Rising Edge에서 D를 저장

### Master-slave D flipflop

(멋진 time 다이어그램)

D가 무작위로 주어졌을떄
Q_master는 클락이 0일때 (클락이 마스터를 활성화시킬때)만 입력을 받고
최종 Q (=Q\_slave)는 클락이 1일때 (클락이 슬레이브를 활성화시킬때) Q_master의
입력을 반영받음

플립플랍: 클락이 Rising edge 일때의 입력 D를 저장하여, 출력하는것이 플립플랍

랫치: 그냥 마지막 입력을 저장하여 출력하는것이 랫치

### Register

한번 정보를 저장하면, 입력이 바뀌어도 정보가 계속 유지되는 장치.

(그림)

이게 개념적으로 이런식으로 작동한다는거지 실제로 이렇게 만드는건 아님

### 1-bit register

(멋진 time 다이어그램)

Load signal이 1이고, rising edge인순간 그 값을저장함.
Load signal이 0이면, 입력이 뭐가 되든 저장된 값이 유지됨.

### Counter

Rising edge마다 숫자가 1씩 증가하는 N-bit register.

Modulo-4 counter. Program counter

프로그램 카운터가 모에요
컴터가 다음으로 실행할 인스트럭션의 주소가 저장된 레지스터요
모에모에큥
그럼 카운터가 몇씩 늘어요
워드단위로 늘어요 (RISC 기준. 요즘 CISC는 추세랑 안맞아서)
워드가 모에요
컴퓨터가 기본으로 처리하는 정보의 단위요

### State table

입력, 출력, State간의 시간에 따른 관계를 나타냄

modulo-4 counter의 state table은 아래와 같음

### FSM

동기식 순차 논리회로는 FSM과 1:1 대응됨.

### Mealy FSM

출력 함수 H가 현재상태와 입력의 함수일때, 즉 H:S X I -> O

### Moore FSM

출력 함수 H가 현재상태만의 함수일때, 즉, H:S -> O

### FSM의 구현

출력 함수 H와 다음상태를 정의하는 전이함수

### Random Access Memory

컴퓨터에서 주로 쓰는 메모리. 이진 정보가 RAM에 워드 단위로 저장됨.

워드가 액세스되는 순서 없이 워드를 읽거나 쓸때 동일한 시간이 걸리는 메모리를
뜻함. 램 내 워드의 위치는 접근속도에 영향을 미치지 않음

RAM의 용량 또는 크기 = 저장할 수 있는 총 비트의 개수

RAM의 구성
*   워드의 갯수 * 비트로 나타낸 워드의 크기

### RAM Cell

Data\_in, select, write가 입력으로 들어오고 Data_out이 출력으로 나감

RAM 여러개를 CS(Chip Select)비트로 또 동시에 여러개를 조종함.

### 큰 용량의 RAM 구현하기

Word를 냅두고 칩을 늘려도 되고, Word를 늘리고 칩을 냅둬도 됨

## RAM의 액세스

전파지연(propagation delay)때문에 타이밍 관련 이슈가 많음.

1.  Addr 입력을 주면 아웃풋이 나오는데, 데이터가 불안정함. 데이터가 제대로
    출력되기까지 시간이 필요함
1.  유효한 주소를 넣기 시작한 순간부터, 유효한 데이터가 처음 나오기까지의 시간을
    메모리 액세스 시간(Memory Access Time)이라고 함. 보통 60~55ns 걸림
1.  이 이외의 상태에서는 tristate buffer가 끊어진 상태(하이 임피던스) 상태로
    존재함.

쓰기도 비슷함.

### DDR2, DDR3, DDR4

### Assignment

DRAM에서, DDR2, DDR3, DDR4 각각이 무엇을 의미하는지 조사를 해오기. LPDDR3, LPDD4
(Low power, 서너배 비쌈) 이것도 조사해와.
