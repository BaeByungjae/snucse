> 3월 4일

### Memory Wall

메모리 성능은 1년에 10%정도밖에 향상이 안됨. 그래서 60년대 말에 Cache라는
해결방법이 나옴, 아주 잘 쓰이고 있음.

연구를 하기위해서는 Practical 한 솔루션을 제시해야돼요.

멀티코어가 나오고 나서는 캐쉬 구조가 달라짐. ILP Wall과 파워 장벽은
멀티코어로극복했지만, 메모리 장벽은 멀티코어로 극복하지 못했지만 클락이 더
빨라지진 않을테니 오케이

### Programming wall

코어의 갯수가 늘어나도 프로그램이 바뀌지 않으면 의미가 없음.

멀티코어의 성능을 충분히 이끌어내려면 소프트웨어를 잘 병렬화시켜서 만들어야함.

멀티코어 붐이 일었을때 수많은 회사들이 있었지만 이제 IBM, SGI 밖에 안남음. 이
회사들이 왜 다 망했느냐? 몇십억짜리 시스템을 다 사놔도 프로그래머를 뽑기가
힘들어. 그래서 다 고철덩어리가 되는거야. 이게 지금까지의 문제

이게 굉장한 난제이다. 어떻게하면 이 장벽을 뛰어넘을 수 있을까?

### Programming model

응용프로그램을 개발할때 프로그래머와 병렬 컴퓨터 간의 인터페이스

여러분들이 프로그래밍 할때 하드웨어보고 하는거 아니잖아. 어떤 가상의 머신 위에서
하잖아? 그게 바로 프로그래밍 모델. 근데 우리 ILP Wall 전력장벽 해결 왜한겨?
성능해결하려고 한거지? 쉽게 프로그래밍 하게만들겠다고 성능을 잃어선 되겠느냐?
안됌. 근데 알다시피 쉽게 만드는거랑 성능을 최적화하는거는 서로 상충해. 쉽게
만드려면 추상화가 많이 필요하거든.

### 병렬 프로그래밍 모델의 종류

* 셰어드 메모리 패러렐 프로그래밍 모델
  - 오픈엠피
  - 피쓰레드
* 메세지 패싱 페러렐 프로그래밍 모델
  - MPI
* 엑셀러레이터 프로그래밍 모델
  - OpenCL
  - SnuCL
  - CUDA
  - OpenMP, OpenACC
* 옛 프로그래밍 모델에 안주하려는 경향이 있는 사용자를 기술발전의 추세에 맞게
    교육하는것이 중요

OpenMP는 굉장히 쉽게 만들어져있지만 실제로 써보면 성능최적화 이끌기 힘들어. 내가
직접 다룰수있는 여지가 적거든. 메세지패싱에선 MPI가 de facto 표준. 성능도
엄청나게 좋고 클러스터에 쓰기 적합하다. 그리고 이제는 Practical하게 쓰이는
가속기에 쓰이는 프로그래밍 모델들.

SnuCL은 OpenCL의 클러스터버전 내(이재진 교수님)가 만들었당. OpenMP 4.0은
엄청나게 많은 회사들이 밀고있고, OpenACC는 네개의 큰 회사가 밀고있다. OpenACC
한번 써봐요 얘 성능이 하나도 안나와. OpenMP는 미국 국립연구소 (로렌스랩,
등등)에서 써서 스탠더드가 됨. 근데 OpenMP 4.0은 스펙만 있고 구현체가 없어 (?)
3~4개월 안에 나옴. CUDA는 많이 쓰죠. 이게 제일 먼저 나옴. CUDA는 엔비디아 사유
프로그램이라 아무나 구현체를 못만듬. 그래서 OpenCL이 거기에 대항해서 나옴.
OpenCL은 GPU 안가리고 다 돌아가는데 CUDA는 엔비디아에만 들어감. 삼성 타이젠 삼성
시계에 들어가는 OpenCL 구현체 우리가 만든거임. OpenCL 로고도 애플이 가지고있음.
애플이 OpenCL 밀고 내부적으로 많이 사용하고있음. 지금 AMD, Intel이 많이
밀고있다. Intel과 nVidia은 원수간의 원수. 요즘 게임할떄 아니면 그래픽카드 써요?
온보드 그래픽카드 사요? 그거 다 CPU 안에 들어있는거. 인텔이랑 AMD가 APU 만들어서
엔비디아가 시장을 많이 잃었어. 그래서 예전에 인텔에서 논문 많이 쓰면 엔비디아
이름도 많이 나오고 그랬는데 요즘은 논문에서 엔비디아 상호도 못쓰게한다.

실제로 기술이 발전을 하면 뭐해? 사용자들이 배우기를 해야지. 옛날거에 안주하면
안돼. 프로그래밍 장벽을 극복하기위해 노력을 하자.

### 본 과목에서 다루는 주제

* 순차컴퓨터 시스템의 구조 및 소프트웨어의 동작원리
* 병렬성
* 병렬 컴퓨터 시스템의 구조 및 소프트웨어의 동작원리
* 가속기의 구조
* 병렬화, 벡터화, 동기화 방법
* 메모리 계층구조에 대한 최적화, 루프 최적화, 기타 최적화
* Ptheads
* OpenMP
* MPI
* OpenCL
* CUDA
* SnuCL

맨처음에 컴퓨터 파워 온 하면 어떤동작이 일어나나? 컴구나 시프나 오에스에서
안배웠나.

여러분 OS에서 베컨트 알고리즘, 데이컨트 알고리즘 배웠죠. 그거 텍스트북 틀렸어요.
그거 돌려봐. 안돌아가. **지금 세상에 나와있는 OS책 다 틀렸어.** 지금 멀티코어
아키텍처에서 그거 돌리면 그거 다 안돌아가. 상호배제할때 쓰는 동기화 방법 그거
실제로 C로 임플리먼트해서 돌려봐. 메모리 컨시스턴시 고려를 안하면 안돌아가.
그런것들 실제로 안되는거 이세상에 아는사람 몇명 안될거야. 30년전에나 잘되던
방법이야.

멀티코어에서도 캐쉬를 잘 다루는거 중요해요. nVidia 2007년도에 CEO가 서울대
방문한거 알아요? 좋은사람같던데 왜그러나 모르겠어. 아무리 회사라도
아카데믹한곳에선 그런짓 하면 안돼.

SnuCL은 OpenCL 같은 스펙에, 클러스터 위에서 돌릴 수 있도록 만든 새 구현체.
코딩을 새로 할 필요가 없다. AMD에서도 홍보해준다.

> Lecture 2

컴퓨터와 기수법
--------

### 컴퓨터

계산기. 내부 구조가 아주 복잡. 보통 블랙박스로 추상화. 추상화라는건 이제 우리가
관심없는건 신경안쓰고 관심있는 특성만 보자.

### 데이터

사전적 정의: 추론 논의, 계산의 기반이 되는 측정이나 통계에 의해 얻어진 사실적
정보

컴퓨터공학에선? 컴퓨터로 처리할 수 있는 형태로 구성된 사실적 정보

요즘 빅데이터 유행하지? 빅데이터에서 중요한게 뭘까. 빅데이터엔 중요한 세가지
특정이 있어요. 3V, 볼륨, 버라이어티, 벨로시티. 이게 중요해. 중요한건 분석방법.
통계를 이용해서 분석하지. 새로운 분석방법은 뭐 소셜베이스 외엔 별로 없고. 이건
새로운게 하나도 없는데 그냥 포장만 새로 한거야.

우리나라에서 빅데이터라고 할만한게 얼마나 많을까? 엑셀에 안들어가면 빅데이터라고
쳐봐. 엑셀에 16만로우까지 안들어가. 우리나라 전국민 건강보험 데이터가
300메가밖에 안돼. 이So

중요한건 데이터가 큰것보다 빠르게 처리하는거야. 데이터가 아무리 많아도
처리하는데에 한달이 걸리면 뭐하나? 처리하는동안 데이터 가치가 다날아가. 이걸
어떻게 빠르게 처리하느냐? 멀티코어야.

### 0과 1을 나타내는 전기신호

명확히 구분되는 두가지의 서로 다른 상태: 0과 1. 0.1볼트 근처는 0, 5볼트 근처는
1. 노이즈가 있어도 쓸 수 있도록.

### 하드웨어와 소프트웨어

* 하드웨어
  - 컴퓨터 시스템의 물리적 구성요소
* 소프트웨어
  - 여러개의 프로그램으로 구성된 집합
* 프로그램
  - 주어진 입력을 가지고 원하는 출력을 얻기위해 무엇을 해야하는지 컴퓨터에게
      지시하여 컴퓨터를 동작시키는 역할을 함

### 순차 컴퓨터 시스템

* 우리가 흔히 알고있는 시스템. 패러렐과 비교하여 이야기할떄 사용하는 용어.
* 하드웨어, OS, 어플리케이션 크게 세 요소로 추상화됨

### Application

* 응용소프트웨어. 줄여서 응용(어플)이라고 부름
* 사용자가 특별한 작업을 수행할때 도움을 주는 음용 프로그램의 집합

### 시스템 소프트웨어

컴퓨터 하드웨어를 운용하고 응용 소프트웨어를 실행하기위한 플랫폼.

ex) OS, CLI, Windows, Compiler, Debugger

### 유틸리티 소프트웨어

시스템 소프트웨어의 일종

컴퓨터 하드웨어와 소프트웨어를 관리하고 튜닝할떄 이용

ex) 백신, 압축프로그램, 파티셔너, 모니터, 어셈블러

얘네는 다 구분이 모호하다. 엄격하게 구분 못지어. 이거 구분하고있는놈들은
할짓없는 놈들이야

### r-진법

위치기반 기수법 (positional number system)

수는 숫자들을 연이어 나열한것으로 표현, 그 표현이 가지는 값은 각 숫자가 가지는
값을 더한것. 각 숫자의 값은 숫자의 위치에 따른 무게값에 따라 결정됨.

소숫점 (radix point)

수라는 개념은 절대적이야. 십진법, 십육진법 이런건 우리가 그 수를 표현하기위해
만든것들일 뿐이야.

### 흔히 사용하는 기수법의 기수와 숫자

이진법
팔진법
십진법
십육진법

여러분 팔진법은 요즘 잘 안쓰죠? 그리고 십육진법은 숫자가 모자라니까 알파벳 (A,
B, C, D, E, F) 을 쓰지.

기수법은 별로 안좋은게 이진수, 십진수, 팔진수 다 같은 숫자 (digit)을 써서 문맥에
따라 모호할떄가 있어. 이럴땐 명확하게 해주지

### Fixed-point repr

소수점이 어떤 위치에 고정되어있다고 가정. 소수점을 컴퓨터 내부에서 표시할 필요가
없음.

### 진수변환

이진수 -> 팔진수, 이진수 -> 16진수는 그냥 세개 네개씩 묶으면 된다.

### 십진 정수 N을 이진 정수로 변환하는 방법
### 십진 소수 N을 이진 소수로 변환하는 방법

### 정수부와 소수부가 조합되어있는경우

각부분을 따로 변환해서 결과를 조합

### 십진수를 8/16진수로 변환하기

십진수를 이진수로 바꾸고, 그걸 8/16진수로 변환.

### Unsigned integer

이진수가 0이나 양의 값을 나타낼 때.

n비트 언사인드 인티저 x의 범위: [0, 2**n)

### Signed integer

부호 붙은 수를 n개의 비트로 인코딩하는 방버

1.  부호붙은 크기 표현
1.  1의 보수
1.  2의 보수
    * 하드웨어 구현이 제일 간단함. 대부분의 컴퓨터가 사용중

옛날엔 1의보수, 부호붙은 크기를 다 썼지만 2의 보수가 제일 좋다. 제일 간단하다 =
트랜지스터가 적다 = 빠르다, 그 공간에 다른일을 할 수 있다.

### 보수

r진법으로 표현된 n개자리수 x의 r의 보수(radix complement, complement) 는

r**n - x (if x != 0)
0        (otherwise)

x의 (r-1)의 보수(diminished radix complement) x` 는

x` = r**(n - 1) - x;

### 보수 구하기

십진수 836의 (10 - 1)의 보수는 10**3 - 1 - 836 = 999 - 836 = 163

이거 쉬운 계산은 그냥 각 자리수를 (r-1) 에서 빼서 다시 조립하면 됨.

x가 0이 아닌경우, x의 (r-1)의 보수에 1을 더하면 x의 r의 보수를 얻을수있음

### 1의 보수 표현 === (2-1)의 보수

r=2일 경우에, (r-1)의 보수를 사용하여 음수를 표현하는것.

ex) 6의 b1의 보수는 (2**4 - 1) - 6 = 15 - 6 = 9
9는 b1001이고 (2-1)의 보수 표현에서 -6을 나타냄
2**3 을 안쓰는데엔 이유가 있음

MSB는 부호비트
1이면 음수, 0이면 양수

단점. 0을 표현하는 방법이 두개가됨.

0000 = +0
1111 = -0

### 2의 보수 표현

현재 대부분의 컴퓨터가 사용중

n비트 이진수로 표현되는 정수 x의 2의 보수

### 2의 보수 표현의 범위와 값

[-2**(n-1), 2**(n-1) - 1]

### (피피티 참고, 도저히 타자로 못치겠는 슬라이드. 피피티 볼것)

### Modular arithmetic, clock arithmetic

Euclidean algorith

두 정수 m과 n(!=0)이 주어졌을때, m = qn + r, (0<=r<|n|) 을 만족하는 유일한 정수
q와 r이 항상 존재함.

이게 우리가 아는 나눗셈하고 어떻게 다르냐? 음수일경우 다름

일반적인 경우: -7을 3으로 나누면 몫은 -2, 나머지는 -1
유클리디안: -7을 3으로 나누면 몫은 -3, 나머지는 2 (항상 양수여야하니까)

### mod

q := floor(x/m), m != 0

r = x mode m = x - mq, m != 0

m은 modulus 라고 불림

*   앞으로 이용할 성질

    ```
    (a+b) mod n = ((a mod n) + (b mod n)) mod n
    ```

보통사람들이 말하는 소프트웨어는 소프트웨어가 아니에요. 그건 SI야. 그건
전공불문이야 아무나 가서 하면 돼. 그건 컴퓨터과학이 필요하지 않아. 그건
소프트웨어 하는게 아냐. 그건 용역하는거야. 컴퓨터공학 하는데에 필요없는것들.
그건 대단할 놀러지가 필요하지 않아.

### 합동관계 (congruence relation)

나머지가 같으면 합동이다.

### 모듈로-m 연산 (modulo-m operation)

모듈러스가 m인 합동관계를 이용한 연산

m개의 수 0, 1, 2, .. , m - 1을 연산에 이용

예) 모듈로-8 덧셈

1 + 4 === 5 (mod 8)
8 + 5 === 5 (mod 8)
7 + 3 === 2 (mod 8)
0 + 8 === 0 (mod 8)

--------

내가 오늘한것들은 중학생한테 가르쳐도 다 할거야. 중요한건 이 숨은뜻을
이해하는거야.
