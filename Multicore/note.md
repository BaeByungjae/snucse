> 3월 4일

### Memory Wall

메모리 성능은 1년에 10%정도밖에 향상이 안됨. 그래서 60년대 말에 Cache라는
해결방법이 나옴, 아주 잘 쓰이고 있음.

연구를 하기위해서는 Practical 한 솔루션을 제시해야돼요.

멀티코어가 나오고 나서는 캐쉬 구조가 달라짐. ILP Wall과 파워 장벽은
멀티코어로극복했지만, 메모리 장벽은 멀티코어로 극복하지 못했지만 클락이 더
빨라지진 않을테니 오케이

### Programming wall

코어의 갯수가 늘어나도 프로그램이 바뀌지 않으면 의미가 없음.

멀티코어의 성능을 충분히 이끌어내려면 소프트웨어를 잘 병렬화시켜서 만들어야함.

멀티코어 붐이 일었을때 수많은 회사들이 있었지만 이제 IBM, SGI 밖에 안남음. 이
회사들이 왜 다 망했느냐? 몇십억짜리 시스템을 다 사놔도 프로그래머를 뽑기가
힘들어. 그래서 다 고철덩어리가 되는거야. 이게 지금까지의 문제

이게 굉장한 난제이다. 어떻게하면 이 장벽을 뛰어넘을 수 있을까?

### Programming model

응용프로그램을 개발할때 프로그래머와 병렬 컴퓨터 간의 인터페이스

여러분들이 프로그래밍 할때 하드웨어보고 하는거 아니잖아. 어떤 가상의 머신 위에서
하잖아? 그게 바로 프로그래밍 모델. 근데 우리 ILP Wall 전력장벽 해결 왜한겨?
성능해결하려고 한거지? 쉽게 프로그래밍 하게만들겠다고 성능을 잃어선 되겠느냐?
안됌. 근데 알다시피 쉽게 만드는거랑 성능을 최적화하는거는 서로 상충해. 쉽게
만드려면 추상화가 많이 필요하거든.

### 병렬 프로그래밍 모델의 종류

* 셰어드 메모리 패러렐 프로그래밍 모델
  - 오픈엠피
  - 피쓰레드
* 메세지 패싱 페러렐 프로그래밍 모델
  - MPI
* 엑셀러레이터 프로그래밍 모델
  - OpenCL
  - SnuCL
  - CUDA
  - OpenMP, OpenACC
* 옛 프로그래밍 모델에 안주하려는 경향이 있는 사용자를 기술발전의 추세에 맞게
    교육하는것이 중요

OpenMP는 굉장히 쉽게 만들어져있지만 실제로 써보면 성능최적화 이끌기 힘들어. 내가
직접 다룰수있는 여지가 적거든. 메세지패싱에선 MPI가 de facto 표준. 성능도
엄청나게 좋고 클러스터에 쓰기 적합하다. 그리고 이제는 Practical하게 쓰이는
가속기에 쓰이는 프로그래밍 모델들.

SnuCL은 OpenCL의 클러스터버전 내(이재진 교수님)가 만들었당. OpenMP 4.0은
엄청나게 많은 회사들이 밀고있고, OpenACC는 네개의 큰 회사가 밀고있다. OpenACC
한번 써봐요 얘 성능이 하나도 안나와. OpenMP는 미국 국립연구소 (로렌스랩,
등등)에서 써서 스탠더드가 됨. 근데 OpenMP 4.0은 스펙만 있고 구현체가 없어 (?)
3~4개월 안에 나옴. CUDA는 많이 쓰죠. 이게 제일 먼저 나옴. CUDA는 엔비디아 사유
프로그램이라 아무나 구현체를 못만듬. 그래서 OpenCL이 거기에 대항해서 나옴.
OpenCL은 GPU 안가리고 다 돌아가는데 CUDA는 엔비디아에만 들어감. 삼성 타이젠 삼성
시계에 들어가는 OpenCL 구현체 우리가 만든거임. OpenCL 로고도 애플이 가지고있음.
애플이 OpenCL 밀고 내부적으로 많이 사용하고있음. 지금 AMD, Intel이 많이
밀고있다. Intel과 nVidia은 원수간의 원수. 요즘 게임할떄 아니면 그래픽카드 써요?
온보드 그래픽카드 사요? 그거 다 CPU 안에 들어있는거. 인텔이랑 AMD가 APU 만들어서
엔비디아가 시장을 많이 잃었어. 그래서 예전에 인텔에서 논문 많이 쓰면 엔비디아
이름도 많이 나오고 그랬는데 요즘은 논문에서 엔비디아 상호도 못쓰게한다.

실제로 기술이 발전을 하면 뭐해? 사용자들이 배우기를 해야지. 옛날거에 안주하면
안돼. 프로그래밍 장벽을 극복하기위해 노력을 하자.

### 본 과목에서 다루는 주제

* 순차컴퓨터 시스템의 구조 및 소프트웨어의 동작원리
* 병렬성
* 병렬 컴퓨터 시스템의 구조 및 소프트웨어의 동작원리
* 가속기의 구조
* 병렬화, 벡터화, 동기화 방법
* 메모리 계층구조에 대한 최적화, 루프 최적화, 기타 최적화
* Ptheads
* OpenMP
* MPI
* OpenCL
* CUDA
* SnuCL

맨처음에 컴퓨터 파워 온 하면 어떤동작이 일어나나? 컴구나 시프나 오에스에서
안배웠나.

여러분 OS에서 베컨트 알고리즘, 데이컨트 알고리즘 배웠죠. 그거 텍스트북 틀렸어요.
그거 돌려봐. 안돌아가. **지금 세상에 나와있는 OS책 다 틀렸어.** 지금 멀티코어
아키텍처에서 그거 돌리면 그거 다 안돌아가. 상호배제할때 쓰는 동기화 방법 그거
실제로 C로 임플리먼트해서 돌려봐. 메모리 컨시스턴시 고려를 안하면 안돌아가.
그런것들 실제로 안되는거 이세상에 아는사람 몇명 안될거야. 30년전에나 잘되던
방법이야.

멀티코어에서도 캐쉬를 잘 다루는거 중요해요. nVidia 2007년도에 CEO가 서울대
방문한거 알아요? 좋은사람같던데 왜그러나 모르겠어. 아무리 회사라도
아카데믹한곳에선 그런짓 하면 안돼.

SnuCL은 OpenCL 같은 스펙에, 클러스터 위에서 돌릴 수 있도록 만든 새 구현체.
코딩을 새로 할 필요가 없다. AMD에서도 홍보해준다.

> Lecture 2

컴퓨터와 기수법
--------

### 컴퓨터

계산기. 내부 구조가 아주 복잡. 보통 블랙박스로 추상화. 추상화라는건 이제 우리가
관심없는건 신경안쓰고 관심있는 특성만 보자.

### 데이터

사전적 정의: 추론 논의, 계산의 기반이 되는 측정이나 통계에 의해 얻어진 사실적
정보

컴퓨터공학에선? 컴퓨터로 처리할 수 있는 형태로 구성된 사실적 정보

요즘 빅데이터 유행하지? 빅데이터에서 중요한게 뭘까. 빅데이터엔 중요한 세가지
특정이 있어요. 3V, 볼륨, 버라이어티, 벨로시티. 이게 중요해. 중요한건 분석방법.
통계를 이용해서 분석하지. 새로운 분석방법은 뭐 소셜베이스 외엔 별로 없고. 이건
새로운게 하나도 없는데 그냥 포장만 새로 한거야.

우리나라에서 빅데이터라고 할만한게 얼마나 많을까? 엑셀에 안들어가면 빅데이터라고
쳐봐. 엑셀에 16만로우까지 안들어가. 우리나라 전국민 건강보험 데이터가
300메가밖에 안돼. 이So

중요한건 데이터가 큰것보다 빠르게 처리하는거야. 데이터가 아무리 많아도
처리하는데에 한달이 걸리면 뭐하나? 처리하는동안 데이터 가치가 다날아가. 이걸
어떻게 빠르게 처리하느냐? 멀티코어야.

### 0과 1을 나타내는 전기신호

명확히 구분되는 두가지의 서로 다른 상태: 0과 1. 0.1볼트 근처는 0, 5볼트 근처는
1. 노이즈가 있어도 쓸 수 있도록.

### 하드웨어와 소프트웨어

* 하드웨어
  - 컴퓨터 시스템의 물리적 구성요소
* 소프트웨어
  - 여러개의 프로그램으로 구성된 집합
* 프로그램
  - 주어진 입력을 가지고 원하는 출력을 얻기위해 무엇을 해야하는지 컴퓨터에게
      지시하여 컴퓨터를 동작시키는 역할을 함

### 순차 컴퓨터 시스템

* 우리가 흔히 알고있는 시스템. 패러렐과 비교하여 이야기할떄 사용하는 용어.
* 하드웨어, OS, 어플리케이션 크게 세 요소로 추상화됨

### Application

* 응용소프트웨어. 줄여서 응용(어플)이라고 부름
* 사용자가 특별한 작업을 수행할때 도움을 주는 음용 프로그램의 집합

### 시스템 소프트웨어

컴퓨터 하드웨어를 운용하고 응용 소프트웨어를 실행하기위한 플랫폼.

ex) OS, CLI, Windows, Compiler, Debugger

### 유틸리티 소프트웨어

시스템 소프트웨어의 일종

컴퓨터 하드웨어와 소프트웨어를 관리하고 튜닝할떄 이용

ex) 백신, 압축프로그램, 파티셔너, 모니터, 어셈블러

얘네는 다 구분이 모호하다. 엄격하게 구분 못지어. 이거 구분하고있는놈들은
할짓없는 놈들이야

### r-진법

위치기반 기수법 (positional number system)

수는 숫자들을 연이어 나열한것으로 표현, 그 표현이 가지는 값은 각 숫자가 가지는
값을 더한것. 각 숫자의 값은 숫자의 위치에 따른 무게값에 따라 결정됨.

소숫점 (radix point)

수라는 개념은 절대적이야. 십진법, 십육진법 이런건 우리가 그 수를 표현하기위해
만든것들일 뿐이야.

### 흔히 사용하는 기수법의 기수와 숫자

이진법
팔진법
십진법
십육진법

여러분 팔진법은 요즘 잘 안쓰죠? 그리고 십육진법은 숫자가 모자라니까 알파벳 (A,
B, C, D, E, F) 을 쓰지.

기수법은 별로 안좋은게 이진수, 십진수, 팔진수 다 같은 숫자 (digit)을 써서 문맥에
따라 모호할떄가 있어. 이럴땐 명확하게 해주지

### Fixed-point repr

소수점이 어떤 위치에 고정되어있다고 가정. 소수점을 컴퓨터 내부에서 표시할 필요가
없음.

### 진수변환

이진수 -> 팔진수, 이진수 -> 16진수는 그냥 세개 네개씩 묶으면 된다.

### 십진 정수 N을 이진 정수로 변환하는 방법
### 십진 소수 N을 이진 소수로 변환하는 방법

### 정수부와 소수부가 조합되어있는경우

각부분을 따로 변환해서 결과를 조합

### 십진수를 8/16진수로 변환하기

십진수를 이진수로 바꾸고, 그걸 8/16진수로 변환.

### Unsigned integer

이진수가 0이나 양의 값을 나타낼 때.

n비트 언사인드 인티저 x의 범위: [0, 2**n)

### Signed integer

부호 붙은 수를 n개의 비트로 인코딩하는 방버

1.  부호붙은 크기 표현
1.  1의 보수
1.  2의 보수
    * 하드웨어 구현이 제일 간단함. 대부분의 컴퓨터가 사용중

옛날엔 1의보수, 부호붙은 크기를 다 썼지만 2의 보수가 제일 좋다. 제일 간단하다 =
트랜지스터가 적다 = 빠르다, 그 공간에 다른일을 할 수 있다.

### 보수

r진법으로 표현된 n개자리수 x의 r의 보수(radix complement, complement) 는

r**n - x (if x != 0)
0        (otherwise)

x의 (r-1)의 보수(diminished radix complement) x` 는

x` = r**(n - 1) - x;

### 보수 구하기

십진수 836의 (10 - 1)의 보수는 10**3 - 1 - 836 = 999 - 836 = 163

이거 쉬운 계산은 그냥 각 자리수를 (r-1) 에서 빼서 다시 조립하면 됨.

x가 0이 아닌경우, x의 (r-1)의 보수에 1을 더하면 x의 r의 보수를 얻을수있음

### 1의 보수 표현 === (2-1)의 보수

r=2일 경우에, (r-1)의 보수를 사용하여 음수를 표현하는것.

ex) 6의 b1의 보수는 (2**4 - 1) - 6 = 15 - 6 = 9
9는 b1001이고 (2-1)의 보수 표현에서 -6을 나타냄
2**3 을 안쓰는데엔 이유가 있음

MSB는 부호비트
1이면 음수, 0이면 양수

단점. 0을 표현하는 방법이 두개가됨.

0000 = +0
1111 = -0

### 2의 보수 표현

현재 대부분의 컴퓨터가 사용중

n비트 이진수로 표현되는 정수 x의 2의 보수

### 2의 보수 표현의 범위와 값

[-2**(n-1), 2**(n-1) - 1]

### (피피티 참고, 도저히 타자로 못치겠는 슬라이드. 피피티 볼것)

### Modular arithmetic, clock arithmetic

Euclidean algorith

두 정수 m과 n(!=0)이 주어졌을때, m = qn + r, (0<=r<|n|) 을 만족하는 유일한 정수
q와 r이 항상 존재함.

이게 우리가 아는 나눗셈하고 어떻게 다르냐? 음수일경우 다름

일반적인 경우: -7을 3으로 나누면 몫은 -2, 나머지는 -1
유클리디안: -7을 3으로 나누면 몫은 -3, 나머지는 2 (항상 양수여야하니까)

### mod

q := floor(x/m), m != 0

r = x mode m = x - mq, m != 0

m은 modulus 라고 불림

*   앞으로 이용할 성질

    ```
    (a+b) mod n = ((a mod n) + (b mod n)) mod n
    ```

보통사람들이 말하는 소프트웨어는 소프트웨어가 아니에요. 그건 SI야. 그건
전공불문이야 아무나 가서 하면 돼. 그건 컴퓨터과학이 필요하지 않아. 그건
소프트웨어 하는게 아냐. 그건 용역하는거야. 컴퓨터공학 하는데에 필요없는것들.
그건 대단할 놀러지가 필요하지 않아.

### 합동관계 (congruence relation)

나머지가 같으면 합동이다.

### 모듈로-m 연산 (modulo-m operation)

모듈러스가 m인 합동관계를 이용한 연산

m개의 수 0, 1, 2, .. , m - 1을 연산에 이용

예) 모듈로-8 덧셈

1 + 4 === 5 (mod 8)
8 + 5 === 5 (mod 8)
7 + 3 === 2 (mod 8)
0 + 8 === 0 (mod 8)

내가 오늘한것들은 중학생한테 가르쳐도 다 할거야. 중요한건 이 숨은뜻을
이해하는거야.

--------

Lecture 03

부울 대수와 조합 논리회로
--------

*   1854년, George Boole
*   두개의 원소를 가진 집합 {0, 1} 을 정의하고, 이 집합에 대해 정의된 세
    논리연산 AND, OR, NOT 을 만듬
*   클라우드 섀넌의 논문에 베이스를 두고있음. 이때 섀년이 쓴 Information
    Theory가 지금 컴퓨터의 근간을 이룸.

### 부울 식

상수 0과 1, 변수, 논리연산자 and or not 을 포함하는 심볼들로 구성된 문자열.
부울식은 귀납적으로 정의됨

1. 심볼은 부울식
1. exp가 부울식이면 ~exp 도 부울식
1. e1, e2가 부울식이면 (e1 && e2), (e1 || e2) 도 부울식

### 곱셈항과 민텀

*   term, 항

    불 식에서 `+` 로 나뉜 각 부분을 항이라고 함

*   literal, 리터럴

    부울 식에 나타나는 변수 자체 (x)나 변수의 부정 (~x)

*   product term, 곱셈항

    리터럴의 AND 연산만으로 구성되어있는 항

*   minterm, 민텀

    n개의 변수를 가진 부울 식에서 각 변수에 대한 리터럴이 '한번씩만' 나타나는
    곱셈항. 한번씩 다 나와야됨

    예를들어 x, y 두 변수에 대해 나올수있는 모든 민텀은

    - ~x * ~y
    - ~x * y
    - x * y
    - x * y

### 부울 대수의 공리, Axiom

Axiom? 무조건 참이라고 믿는 / 가정하는 논리체계의 기반, 바닥.

* 집합 `B = {0, 1}`에 대한 부울 대수는 여섯 개의 공리를 가짐

1.  B에 속한 모든 x와 y에 대하여 x + y 와 x*y 도 B에 속한다.
2.  B에 속한 모든 x에 대해 x + 0 = x, x*1 = x 를 만족하는 서로 다른 원소 0과 1이
존재한다.
3.  B의 속한 모든 x와 y에 대하여 x + y = y + x, x\*y = y*x
4.  배분법칙
5.
6.

### 부울 대수의 정리, Theorem

* 공리를 이용하여 부울 대수에 관한 여러개의 정리를 증명할 수 있음

B에 속한 모든 x, y에 대하여..

1.  x + x = x, x*x = x
2.  x + 1 = 1, x*0 = 0
3.  (x + y)\*x = x, (x*y) + x = x
4.  (x + y) + z = x + (y + z), (x\*y)*z = x\*(y\*z)
5.  ~x 는 유일
6.  ~(~x) = x
7.  ~(x + y) = ~x\*~y, ~(x*y) = ~x + ~y

### 정리 1의 증명

진리표로 증명함.

사실 5번 빼고 다 진리표 쓰면 됨

### 정리 3의 증명

진리표 안쓰고 공리 쓰면 됨

```
  (x + y)*x
= x*(x + y)
= (x + 0)*(x + y)
= x + (0*y)
= x + (y*0)
= x + 0
= x
```

Term rewriting system을 쓰면, 정리 증명을 자동으로 할 수 있다. 프로그램을 짜면
'이 프로그램에서 이 시점은 x는 항상 1이다' 이런것도 Theorem prooving 기계로 함.

### Boolean function

B = {0, 1} 일때, n개의 변수 x1 x2 .. xn 을 가진 부울 식은 부울 함수 f: B^n -> B
를 정의함

n개의 변수를 가진 서로 다른 부울 함수는 총 2^(2^n) 개

### Functional Completness (함수의 완전성)

어떤 논리연산의 집합에 든 연산만으로 서로 다른 모든 부울 함수를 정의할 수 있으면
그 집합은 Functionally Complete 하다고 말함.

* 어떤 불 함수라도 AND, OR, NOT 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 XOR 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 XNOR 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 NOR 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 NAND 의 조합으로 정의할 수 있음

### 진리표를 부울 식으로 변환하기

*   부울 함수를 부울 식으로 쓸수만 있으면 회로로 만드는 과정은 정말 쉽기때문에
    이런 과정이 필요함
*   n개의 리터럴을 가진 민텀과, n개의 변수를 가진 진리표에 존재하는 입력 값의
    조합은 1:1 대응. n개의 변수를 가진 진리표의 한 Cell은 모두 n개의 리터럴을
    가진 민텀으로 표현 가능하다는 이야기
*   민텀은 대응되는 입력 값의 조합에 대해서만 1이 됨.
*   진리표에서 함수의 결과 값이 1이 되는 입력 값의 조합에 대응되는 민텀을 모두
    구하고, 이들을 OR 연산으로 묶으면 진리표를 부울 대수로 만들 수 있음.

* 반 가산기
  * 두개의 입력 비트 x, y를 더하고, 그 결과로 두개의 비트 s와 c를 출력하는
    전자회로

### 부울 식의 간소화

Karnaugh map

### 로직 게이트

부울대수는 논리회로의 수학적 모델링, 로직 게이트는 이것의 물리적인 구현

*   Propagation Delay

    전달 지연

*   게이트 딜레이

    게이트 하나 통과할때마다 1ps정도 작은 딜레이가 생김

    ```
    <@p> 45~65nm에서 온오프 걸리는 시간이 ps
    <@p> 1ㅔㄴ
    <@p> 1ps
    ```

### 기본적인 로직 게이트

이름  | 트랜지스터 수
------|---------
NOT   | 2
OR    | 6
AND   | 6
NOR   | 4
NAND  | 4
XOR   | 14
XNOR  | 12

### 로직 게이트의 함수적 완전성

*   Universal gate

    Universal gate 하나만으로 모든 부울 함수를 구현할 수 있음

### 로직 다이어그램

Schemetic

### Bus

옴니버스에서 나온 말. 동시에 전기신호가 전송되는 두개 이상의 연관된 와이어들로
이루어진 집합. 버스 내 각 와이어가 한 비트의 정보를 전송함

*   Word

    컴퓨터에서 하나의 단위로 취급하여 처리하는 서로 관련된 비트들의 묶음.
    일반적으로 하나의 워드 안에 든 여러개의 비트들을 동시에 처리하도록 컴퓨터
    하드웨어가 구현되어있음

### Tristate buffer

로직게이트는 아니지만 비슷한 역할을 하기때문에 쓰임

함수표(function table)는 진리표를 압축하여 더 간단히 나타낸것

조합 논리회로
--------

Combinational logic circuit

*   로직 게이트들을 와이어로 연결한 회로, 항상 현재의 입력값들에 의해 그 출력
    값이 결정됨.
*   여러개의 입력과 여러개의 출력을 가짐
*   각각의 출력은 하나의 불함수로 표현됨

### 멀티플렉서

*   셀렉터, MUX
*   2^n개의 입력과 n개의 선택 비트가 들어옴, 한개만 선택되어 출력됨
*   2-to-1, 4-to-1, 16-to-1 멀티플렉서

### 디코더

*   Demultiplexer
*   n개의 입력비트에 대해 최대 2^n개의 출력을 가질 수 있음
*   2-to-4, 3-to-8 디코더
*   enable 입력을 가질때도있음

### 디코더를 이용한 MUX 구현

2-to-4 디코더를 이용해 4-to-1 MUX 를 구현할 수 있음

--------

> 3월 11일

조합 논리회로만으로 ALU (기본 계산의 단위) 다 만들수 있음. GPU에도 이 벌겨 아닌
ALU가 수천개씩 들어있음. 하지만 이걸로 메모리는 커버 못함.

순차논리회로는 메모리와 관련이 있음.

책에 그림 자동으로 배치하는 알고리즘이 아직도 난제임

순차 컴퓨터 시스템 제대로 설명하려면 200~300p 나올거임. 그거 하고나면 컨텍스트
스위칭, 컨커런시에 대해 배울거임. 베이컨스 알고리즘 이런거 다 안돌아간다.

컨커런시에 대한 기반이 없으니, 순차컴퓨터 시스템부터 기반을 아주 잘 잡아놔야됨.
근데 이 쉬운 개념을 생각을 안하고 자기것을 못만드니 기본이 안되는거임.

베이컨스 알고리즘 이런거 다 안돌아가요
캐시 끄고해도 안돌아가
논캐시어블 해도 안돌아가
메모리 컨시스턴시가 보장이 안돼서그래
그거 OS 책쓴사람이 몰라서그래

멀티코어시스템을 공부하려면 싱글코어시스템을 잘 알아야돼요
공부하기 얼마나 편해 그지
이것만 보고 배우면 돼요
여러분들은 기니피그여
너 동물이야 아냐
동물이지
포유류 안의 영장류지
knuth

마이크로소프트 워드로 쓴거에요
레이텍으로도 써봤는데
워드가 더 편해요

아래아 한글에서 이미지 프로세싱하는걸 좀 빠르게 해달라고 막 그러고있는데
워드로 쓰고있어요
knuth 이분이 논문 출판할때 마음먹은대로 안돼서 Tex을 개발했어요.
이걸갔다가 쓰기 어려우니까 레이텍이라는걸 만든사람이 Lamport 라는 사람이에요

knuth 이분은 수학관련 논문이면 변하는게 없어요
어떻게 하면 멀티프로세서 시스템에서 여러개의 프로세스가 correct하게 돌아가는
그런걸 이야기한사람이 lamport에요
안돌아간다 이거야
이사람도 이걸 만들어서 사람들을 굉장히 이롭게 했어요
그게 연구에요 연구
연구를 하면 사람에게 practical하게 도움이 되게 해야지

아주 fundamental하게 그런것도 도움이 되는게 많아요
 여러분 물에 대해 얼마나 알아요
 화장품이 뭐냐
 물 + 기름이에요
 왜 이런얘기를 하느냐
 들어보라고 한번
 기름에다가 물을 넣는거하고 물에다가 기름을 넣는거하고
 성질이 달라져요
 이게 뭐겠어요?

기름을 까뜩채워
그리고 여기다가 계면활성제를 넣어요

그리고 물을넣어
그게 여러분 바르는 연고있지?
그거에요

로션같은거는 물에다가 기름활성제를 넣어서 기름을 넣는거야
이게 애멀젼이에요 애멀젼

ㄱㄴ데 왜 이렇게 되는가가 원리가 규명이 안되어있어
그래서 물에다가 기름썪은건 바르면 시원해요
근데 기름에 물 섞은건 바르면 끈

난 이런걸 왜 해봤을까?
그러게요
여러분이 냉각을 하죠
근데 써버를갔다 냉각을 하는데
근데 수냉식으로 쿨링하다가
이거 터지면 어떻게돼요?
정xxxx이가 이거 한순간의 실수로 3000만원 날렸어
물때문에
응?
과냉각을 시키면 어떻게돼요
그러면 공기중에 구름이생겨
그러면 3000만원 날라가는거야
18도 이하로 서버실을 과하게 춥게만들면 안돼
근데 우리는 5도로 했거든

그래서 날라간거야
근데 기름을갔다가 쓰면
기름은 이런 위험이 없는데
열전도성이 5배 나빠요

근데 우리가 기름에다가 물을 섞으면 비전도성이 유지가 되면서 점도가 굉장히 높아지고 열전도성은 물처럼 좋아져

그래서 내가 화학 실험실에 갔다가 이걸 했어
그래서 이게 됐을까 안됐을까
안됐어 (?)
내가 이거 하려고 논문을 많이 읽어서 기계공학과 논문도 많이 읽어봤는데 별거아니더라구
그래서 그냥 기름으로 했어요
기름이 어떤 기름이겠어요?
미네랄 오일이라고
존슨즈 베이비오일
한말에 오만원 주면 사
이거 하면서 실험에 막 얼굴에 발르니까
보습효과가 있어서
피부가 좋아지더라고
음식에도 들어가요
(멀티코어 수업임)
보통은 미네랄오일 있으면 서버를 그냥 거기다가 담궈버리는데
그러면 귀찮아
서버실이 온 기름천지가 된다고
우리가한건 방열판 안에 기름을 흘려서
터져도 문제가 없지
고런 장점이 있지
거의 세계 최초라고 할수있지
(멀티코어 수업임)
내가 이걸 옆 연구소에 많이 홍보했지
이게 많이 좋은데 대신 방열판이 튼튼해야돼
이게 컴퓨터를 잘 몰라도 상식으로 하는거야
연구란게 원래 그래요
옆길로 이야기가 많이 샜네
순차논리회로가 그래서

순차 논리회로
--------

순차논리회로는 클락을 가짐. 현재의 입력값 뿐만 아니라, state를 갖고 이전
입력값에 영향을 받음.

순치 논리회로 = 조합 논리회로 + 메모리

동기 순차 논리회로, 비동기 순차 논리회로로 나뉨

### 클락

일정한 간격으로 rising edge, falling edge가 생김.

### 랫치 & 플립플랍

우리나라 책들이 이게 아주 헷갈리게 써있어.

커뮤니케이션이 반이야.
앞으로 사회 나가면 소통
생각을 한다음에 남한테 설명하는게 반이라고
남 한번 가르쳐봐요 엄청나게 공부 많이해야돼

메모리는 보통 플립플랍으로 구현됨.

*   하나의 플립플랍은 한개의 비트를 저장
    * 두개의 구분 가능한 상태
*   플립플랍은 보통 랫치로 구현함
    * ..

**플립플랍과 랫치의 차이**

### SR Latch

두개의 입력 Set과 Reset, 두개의 출력 Q와 Q\`

`S = 1 && R = 1` 이 아닌이상 항상 `Q\` = ~Q` 를 만족함

S | R | Q
--|---|---
0 | 0 | Q_prev
0 | 1 | 0
1 | 0 | 1
1 | 1 | *undefined*

`S = 1 && R = 1` 이면, Q가 0과 1로 반복적으로 바뀌는 불안정한 상태에 이름. 허나 그 값이 1이 될지 0이 될지 예측할 수 없음

이걸로 1 비트를 저장할 수 있음

### D Latch

데이터를 지정하는 입력 D

새로운 입력을 받아들일지 말지를 제어하는 입력 C

C = 1 일동안 랫치의 출력이 입력 D에 따라 바로 바뀜

No undefined state

C | D | Q
--|---|---
0 | X | Q_prev
1 | 0 | 0
1 | 1 | 1

### D 플립플랍

D 랫치 두개를 달고, 클락을 달아줌. Rising Edge에서 D를 저장

### Master-slave D flipflop

(멋진 time 다이어그램)

D가 무작위로 주어졌을떄
Q_master는 클락이 0일때 (클락이 마스터를 활성화시킬때)만 입력을 받고
최종 Q (=Q\_slave)는 클락이 1일때 (클락이 슬레이브를 활성화시킬때) Q_master의
입력을 반영받음

플립플랍: 클락이 Rising edge 일때의 입력 D를 저장하여, 출력하는것이 플립플랍

랫치: 그냥 마지막 입력을 저장하여 출력하는것이 랫치

### Register

한번 정보를 저장하면, 입력이 바뀌어도 정보가 계속 유지되는 장치.

(그림)

이게 개념적으로 이런식으로 작동한다는거지 실제로 이렇게 만드는건 아님

### 1-bit register

(멋진 time 다이어그램)

Load signal이 1이고, rising edge인순간 그 값을저장함.
Load signal이 0이면, 입력이 뭐가 되든 저장된 값이 유지됨.

### Counter

Rising edge마다 숫자가 1씩 증가하는 N-bit register.

Modulo-4 counter. Program counter

프로그램 카운터가 모에요
컴터가 다음으로 실행할 인스트럭션의 주소가 저장된 레지스터요
모에모에큥
그럼 카운터가 몇씩 늘어요
워드단위로 늘어요 (RISC 기준. 요즘 CISC는 추세랑 안맞아서)
워드가 모에요
컴퓨터가 기본으로 처리하는 정보의 단위요

### State table

입력, 출력, State간의 시간에 따른 관계를 나타냄

modulo-4 counter의 state table은 아래와 같음

### FSM

동기식 순차 논리회로는 FSM과 1:1 대응됨.

### Mealy FSM

출력 함수 H가 현재상태와 입력의 함수일때, 즉 H:S X I -> O

### Moore FSM

출력 함수 H가 현재상태만의 함수일때, 즉, H:S -> O

### FSM의 구현

출력 함수 H와 다음상태를 정의하는 전이함수

### Random Access Memory

컴퓨터에서 주로 쓰는 메모리. 이진 정보가 RAM에 워드 단위로 저장됨.

워드가 액세스되는 순서 없이 워드를 읽거나 쓸때 동일한 시간이 걸리는 메모리를
뜻함. 램 내 워드의 위치는 접근속도에 영향을 미치지 않음

RAM의 용량 또는 크기 = 저장할 수 있는 총 비트의 개수

RAM의 구성
*   워드의 갯수 * 비트로 나타낸 워드의 크기

### RAM Cell

Data\_in, select, write가 입력으로 들어오고 Data_out이 출력으로 나감

RAM 여러개를 CS(Chip Select)비트로 또 동시에 여러개를 조종함.

### 큰 용량의 RAM 구현하기

Word를 냅두고 칩을 늘려도 되고, Word를 늘리고 칩을 냅둬도 됨

## RAM의 액세스

전파지연(propagation delay)때문에 타이밍 관련 이슈가 많음.

1.  Addr 입력을 주면 아웃풋이 나오는데, 데이터가 불안정함. 데이터가 제대로
    출력되기까지 시간이 필요함
1.  유효한 주소를 넣기 시작한 순간부터, 유효한 데이터가 처음 나오기까지의 시간을
    메모리 액세스 시간(Memory Access Time)이라고 함. 보통 60~55ns 걸림
1.  이 이외의 상태에서는 tristate buffer가 끊어진 상태(하이 임피던스) 상태로
    존재함.

쓰기도 비슷함.

### DDR2, DDR3, DDR4

### Assignment

DRAM에서, DDR2, DDR3, DDR4 각각이 무엇을 의미하는지 조사를 해오기. LPDDR3, LPDD4
(Low power, 서너배 비쌈) 이것도 조사해와.

--------

연구는 실용적으로 해야돼

우리나라 대학 50개만 남기고 싹 정리해버려야돼

대학에서 놀면 안되죠? 죽도록 시켜야지 공부를

국민의 세금을 응 그렇게 써서 돼?

내 애들이 잘사는 세상을 만들려면 여러분 교육을 잘 시켜야돼. 내 애들이 아직
어리단말이야.

내가 외과의를 하고싶은데 나이가 들면 못할거같아.

요즘들어 난 땡기는게 그거야
외과 들어가서 수술 한번
손으로 한번

외과 수술을 하려면
눈도 좋아야하고
손도 안떨려야돼
근데 15년 후엔 떨려야할거야


짜릿하잖아
하나 끝내고나면

응급실에 있으면 계속 짜릿하겠지
나: 교수님 혹시 허트로커라는 영화 아시나요

나: 거기 주인공도 그 짜릿함때문에 폭탄해체반을 제대를 못하고 계속 군복무를
하는데요
폭탄해체는 하기싫어
난 고등학교때 우리나라에선 골프 안치겠다고 평생 결심했어

그리고 한국들어와선 평생 골프 손 안대고있어요
골프장 만드는건 우리나라엔 백해무익해
운동하고싶으면 탁구를 치지

확실하게 배워서 간다 이렇게 생각해야돼

이진 정수의 연산
--------

### 이진 정수의 시프트 연산

Logical shift (>>)

Arithmetic shift (>>): 빈공간을 MSB로 채움. 부호비트 보존

### 시프트 연산과 곱셈, 나눗셈

2의 거듭제곱 곱하는걸 시프트로 표현할 수 있음.

부호없는수에 8 곱하고싶으면 그냥 << 3 하면 됨.
2의 보수도 똑같음. -3에 <<3 하면 *8 이랑 똑같음

오른쪽으로 시프트하는것도 나눗셈. /8 하고싶으면 >>3 하면 됨. 근데 유클리디안
디비젼임.

-7을 4로 나누면 -7 = 4\*(-1) - 3이 아니라, -7 = 4*(-2) + 1. 실제로 -7 에서 >>3
하면 -2 나옴. 근데 C에서 나눗셈하면 유클리디안이 아니라 우리가 아는 나눗셈이
나옴.

### C 언어의 시프트 연산

오른쪽시프트와 왼쪽시프트 연산을 지원

C99 표준은 음수에 대한 오른쪽 시프트를 정의하지 않음. 컴파일러 디펜던트임.

### Sign extension

작은 자리수의 2의 보수를 큰 자리수로 늘릴떄, 생기는 빈 공간을 MSB로 채우기. 그게
바로 사인 익스텐션

### Unsigned int의 덧셈

더해YO. 오버플로우 생기면 자르고 오버플로우 비트에 표시하면 돼.

n비트 unsigned int 의 덧셈은 module n**2 연산을 수행하는거랑 같음.

### 2의 보수 표현의 덧셈

그냥 unsigned int라고 생각하고 무식하게 더한다음에 계산 다 하고 2의 보수
표현으로 읽으면 됨.

왜 `1 + 1 = 2` 인가? Peano arithmetic.
http://en.wikipedia.org/wiki/Peano_axioms

##### Overflow

2의 보수는 오버플로우 체크가 조금 특이함. 덧셈을 계산할때 MSB로 들어가는 carry랑
MSB에서 나오는 carry랑 다르면 오버플로우임.

### 전가산기 & 반가산기

반가산기

x,y를 더해서 합 s와 carry 출력

전가산기

x, y, c\_in을 받아서 합 s 왜 c_out 출력

하프애더 하나와 전가산기 n-1개로 n비트 가산기를 만들 수 있음

unsigned int, signed int의 덧셈 하드웨어는 오버플로우 감지만 다르고 다 같음.

### 이진 정수의 뺄셈

Unsigned

걍 무식하게 하면 됨

2의 보수

x - y = x + (-y) = x + y' + 1

반감산기, 전감산기

n비트 adder 살짝 바꾸면 n비트 subtracter 만들수있음 (x - y = x + y' + 1)

### 부호 없는 수의 곱셈

십진수 곱셈이랑 같은 원리로 함.

근데 회로도 그렇게 짜느냐? 망함

시프터랑 덧셈기 여러개로 곱셈기 만들수도 있음.

곱셈. 진리표를 부울 대수로 펴서 연산자 갯수를 제일 줄여서 이걸 해보자.

CPU 만드는건 쉬워
성능이 안좋아서 그렇지
그얘기 해줄까?
지루할거같으니까
에테아라는게 있죠
ETH
아인슈타인 나온데에요
스위스 연방대학
스위스에서 제일 좋은학교인데
여기에 니콜라스 wirth라는 사람이 있어
늙어서 80이 생겼는데
치매끼가 있는거같애
늙어서 치매가 안올라며
담배를 많이펴야돼
치매 걸릴 기회가 없으니 치매를 안걸리시겠죠 교수님
PASCAL 만든사람이야
프로시져 랭귀지 만드는
이거 공로로 튜링 어워드를 만든 사람이에ㅛ
이걸가따 쪼금떠 발전을 시킨게
Oberon 랭귀지를 만들어서 거기선 이제 학생들 만들땐 이걸 쓰고
Oberon OS 도 있어
Oberon 프로세서도 있다고
그래서 거기엔 C랑 C++을 안가르쳐
미친놈들
Oberon에 OOP 개념도 있어
이야기하는 이유가
여러분들 별로 어려운게 아니라고
CPU 디자인하는거
다 할수있어
다만
테이프아웃하고 최적화 하는거
트랜지스터 뭐 수도없이 많이써도 얼마 들지도 않을거고 최적화 안하면 만드는건 쉬워
OS 만들어서 얹고
컴파일러 만들어서 얹고
한명이면 할수있어
엣날에 그런생각을 했는데
학부 1학년 2학년한테
과목을 4개를 연달아서 해서
CPU -> OS -> 컴파일러 다 만드는걸 해서
학생 1인당 1 컴퓨터를 만들게하는걸
생각을했어
다른학교에서 굉장히 2년연속해서 버클리에서 이런식으로 한번 했었어
여러분 이렇게 하면 배우는게 굉장히 많 다고
여러분 이런 경험 한적 있어요?
너 OS 들었니
너 OS 만들어봤어
나: 아니요
OS 안들었어?
아직이요
왜안들었어
아직 들을 나이가 안됐어요
너 15학번이야
13이요
너 몇학년이야
2학년이요
1년 휴학했어요
근데 이건 왜들어
\>ㅅㅇ
(?)

이런건
납땜하지말고
FPGA로 만들면
여러분도 쉽게 CPU 만들수있어요
얼마나 좋아

### 부호 없는 이진수의 나눗셈

십진수의 나눗셈과 원리가 같음

나이브하게 구현하면 아까꺼랑 똑같음 대신 MUX가 좀 많이 들어감. 복잡함..

### 2의 보수의 이진수 나눗셈

```
resut := x / y
```

left, rigth 의 부호를 잘 조작하면 됨.
유클리디안 나눗셈 말고, 우리가 아는 나눗셈은 부호 떼버린다음 나눗셈하고 나중에
다시 부호를 붙이면 됨.

줜내복잡함.

빠르게 나눗셈하기: http://arith.stanford.edu/~hung/papers/asilomar.pdf

시험문제는 어떻게 낼거냐
이걸 구체적으로 물어볼건 아니고
이걸 어떻게 하는가 설명을 시킬거야
그러니 이걸 이해를 해야돼
아까 디비젼 하는 진리표를
논리게이트로 옮긴거뿐이야

--------

> 3월 18일 수요일

부동소수점
--------

### 과학적 표기법
m * b^e

m: mantissa
e: exponent
b: base

### 정규화된 과학적 표기법
m의 범위를 [1, b)로 한정시킴

이렇게하면 0 외의 모든 수는 표현할 수 있음


### 부동 소수점 표현

### IEEE 754
1985년에 제정됨, 2008년에 IEEE754-2008로 개정됨

1.  32, 64, 128비트 - 세가지 이진 부동소수점 기본형식
1.  십진 부동소수점
1.  Extended precision format - 확장 정밀도 포맷의 기준. 80비트짜리

### IEEE 754 이진 부동소수점 표현
* 32: 단정도
* 64: 배정도
* 128: 사배정도

sign 비트 1개
E 비트 w개
F 비트 k개

1+w+k = n

case                     | kind
-------------------------|-----------
E == 00..0, F == 0.00..0 | +-0
E == 00..0, F != 0.00..0 | 서브노멀 값
E != 00..0, E != 11..1   | 정규 값
E == 11..1, F == 0.00..0 | +-INF
E == 11..1, F != 0.00..0 | NaN

### 라운딩
* 어떤 실수는 그 값은 IEEE 754로 정확하게 표현할 수 없음
  * 그 수에 가장 가까우면서 부동소수점 표현으로 표현할 수 있는 값으로 어림잡아 표현
* Rounding: 더 적은 수의 자릿수를 가진 값으로 주어진 수를 어림잡는 작업
* Rounding error, Round-off error: 원래의 값과 라운딩한 값의 차이

* Round to the nearest, ties to even
* Rount to the nearest, ties away from zero
* Round towards +INF, rounding up, ceiling
* Round towards -INF, rounding down, floor
* Round towards -INF, truncation

floor와 truncation의 차이? 음수

70년대엔 1달러가 꽤 큰돈이었는데, 그당시에 책 앞머리에 틀린말 있으면 1달러
이러곤 했음

### 이진수의 라운딩
이진수의 경우도 십진수와 같은 규칙을 적용할 수 있음

표준에 내정된 라운딩 규칙: Round to the nearest, ties to even

### 정규 값
Normal value, Normalized value

E != 00..0, E != 11..1 일때

v = (-1)^s * m * 2^e, 1 <= m < 2

소수부 F의 왼쪽에 암묵적인 1과 그 사이에 소수점이 존재함을 가정

0 ~ 1000 1100 ~ 1011 1111 1010 0100 0000 000

일때

e = E - bias = b10001100 - 127 = 140 - 127 = 13
m = 1 + f =

##### 고정소수점에서 IEEE 754로 바꾸기

```
  103.625
= b1100111.101
= 1 * b1.100111101 * 2^6
=
```

```
  -3.141595 * 10^10
= -1 * b1.110101000010001001010110101011 * 2^32
 (round to nearest even)
= -1 * b1.11010100001000100101011 * 2^32

0 | 0010 0000 | 1110 1010 0001 0001 0010 101
```

### 서브 노멀 값
Subnormal value, Denormalized value

E = 00...0, F != 0.00...0

v = (-1)^s * m * 2^(1-bias), 0 < m < 1

m의 값은 소수부 F의 값을 f라 할 때, m = f

서브노멀 값은 소수부의 바로 왼쪽에 소수점을 가정하나 정규값처럼 암묵적인 1을
가정하지 않음

```
  2^(-149)
= 1 * 0.00000000000000000000001 * 2^(1-127)

0 | 0000 0000 | 0000 0000 0000 0000 0000 001
```

### 오버플로우와 언더플로우
서브노멀 값, 0은 언더플로우로 취급

+INF, -INF는 오버플로우로 취급

### INF
E = 11...1, F = 0.00..0

IEEE 754엔 무한대에 대한 연산도 정의되어있음

n / INT = 0.0
-n * INF = -INT

+INF 는 모든 정규값, 서브노말값보다 큰것로 정의됨
-INT 는 모든 정규값, 서브노말값보다 작은것으로 정의됨

### NaN
Not a Number

E = 11...1, F != 0.00...0

계산의 결과값을 나타낼 수 없을때 사용 (`0/0`. `sqrt(-1)`, ...)

NaN이 들어가는 비교연산은 `NaN != NaN`만 true이고, 그 외엔 무조건 다 false임

### x86 80-bit extended precision
Intel의 80x87 계열의 부동소수점 Coprocessor를 위해 처음 제안되었고, 그 이후 x86
아키텍처의 부동소수점 연산장치에서 계속 사용함

바이어스된 지수의 바이어스는 16383
실제 지수 e는 E-16383 으로 계산됨

얘는 암묵적인 1이 없고, 비트에 1로 표현되어있음

* QNaN
* SNaN
* undefined
* normal values
* subnormal values
* pseudo-denormal values

1 | 100 0000 0010 0001 | 1 | 1101 0100 0010 0010 0101 0110 1010 1100 ...

익셉션이 모야. 트랩이랑 폴트 그거 다 비슷한거야

### 부동소수점 연산

교환법칙 commutativity
결합법칙 associativity

* 실수의 덧셈은 교환법칙과 결합법칙이 성립
* 라운딩때문에 덧셈, 곱셈 결합법칙은 성립 안함

점점 커지는 숫자 여러개를 더할때 작은것먼저 더하는게 나을까 큰것먼저 더하는게
나을까? - 작은거 먼저 더하는게 나음.

### 부동소수점 표현의 덧셈과 뺼셈
* 뺄셈은 음수취해서 덧셈하면 됨
* 먼저 지수가 더 큰수의 소수점에 맞춰서, 두 수의 지수를 일치시킴
* 가수를 더함
* 가장 가까운 짝수로 라운딩

### Round-off error
```
x = (-1)^s * m * 2^e, 1 <= m < 2

|m_r - m| <= 1/2 * 2^(-23)

|x_r - x| / |x| <= 1/2 * 2^(-k)
```

라운드 오프 에러의 상한을 정할 수 있음. 이를 엡실론, 유닛 라운드오프라고 함.

엡실론 다 배웠지
(나) 넹
칼큘러스할때 다 가르치나
(나) 넹
이해했어?
(나) 넹
이해했다고 느낀건 아니고?
(나) 사실 둘이 구분하기 어렵지 않나요
몰라
그거 수학과 3학년도 이해하면 대단한건데

### 부동소수점 표현의 곱셈
곱셈이 더 쉬움 (지수 맞추는 과정이 생략됨)
부호는 곱셈 하고 따로 수행

### 부동소수점 표현의 나눗셈
지수끼리 빼고, 가수끼리 나눠서 수행.

### Fused Multiply-Add
`x*y + z`를 한번에 수행할 수 있음

FMA 연산을 수행하는 특별한 연산장치
* FMA 연산을 위한 머신 인스트럭션을 제공
* 요즘 대부분의 CPU/GPU가 이를 제공
* 컴파일러 옵션 주면 이거 쓸 수 있음

FMA가 유용한 경우

* Dot product
* 행렬곱
* 다항식의 계산 (묶어서)

속도뿐만 아니라, 정확도도 높아짐 (라운딩을 한번만 해서)

### 반올림을 안하고 nearest even으로 간 이유
더 공평해서? 하드웨어를 만들기 쉬워서? 몇년간 논의가 있었긴 했을거임

### 96, 128 비트가 아니라 80비트를 쓴 이유?
80비트로 하면 F가 64비트로 딱 떨어져서 계산하기에 좋았었음

--------

> 3월 23일

암호를갔다가 해독하는 작업인데 어떻게하면 빠르게할 수 있느냐
내가 하는거랑 앨런튜링이 하는거랑 뭐가 다를거같아
앨런 튜링은 암호 해독 체계를 발견한 사람이고
나같은경우는 무식하게 빠르게
예를들면 패스워드를 알아낸다
제일 쉬운방법이 모에요
몽땅 다 트라이해보는거야
그럼 빨라야될거아냐
원래 컴퓨터라는게 뭐하는거에요?
단순 작업을 무식하게 빠르게 하는게 컴퓨터야
AI, 머신러닝
별거있을거같지
별거없어
안그러면 뭐
그게 안돼요
그냥 빠르면 장땡이야
단순 작업을 빠르게 하는거야
예를들어 단백질 구조분석을 한다고 쳐보자
이게 뭔가 대단한게 있을거같지
별거없어
F = ma 계산을 갔다가 초당 수백만번을 하는거야
수백만번이 모야
몇조번을 하는거지
굉장히 간단한거에요
근데 그것때문에 굉장히 특별한 컴퓨터를 만들잖아
원래 이거 다 단백질 구조분석을 하려고 만든건데
잘돼서 그냥 팔고있는거야
뭔가 문제를 풀려그러다가 나온건데
(갑자기 폰노이만 아키텍처로 넘어감)

CPU
--------

어줍잖게 아는게
모르는거보다 더 안좋은거야
알라면 확실히 알아야돼
생각좀해
생각을 하고 정확한 답인가를 보고
니 생각을 논리적으로 argu를 해봐
stored program concept

폰노이만 아키텍처가 뭐가 특별해요? Stored Program Concept야. 문제를 하나 풀고
선을 다시 연결할 필요가 없어. 어디다가 저장을 했다가 다시 불러와서 쓰면 된다
이거지.

'프로그램 내장 방식' 참정확한 번역이 아냐. 참
안타까워요. 우리 나와있는 컴퓨터 90%는 다 쓰레기야. 자기딴에는 뭐 필드에서
지식이 싸였다고 쓰는데 전부 엉터리야.

30년대가 참 많은게 발견된 해야. 그 연도에 처치인코딩이
튜링머신과 1:1 대응되다는게 발견되었다
하버드는 데이터랑 코드 분리된것
람다칼큘러스 한번 배워봐
알만해
너무 수학적으로 가서 문제지
나도 배우고 한번도 안써봤어
실제로는 컴퓨터 구조에 대해 더 잘알고있는게 훨씬 필드에 도움이 돼

### Stored Program Concept

프로그램을 실행시킬때 선을 다시 연결하지 말고, 펀치카드같은데에 프로그램의
정보를 저장해놓으면 알아서 실행을 해주는것.

예전에도 말했지만 이 핸드폰에 들어가는 기술 진짜 아무것도 아냐. 이거는
머라그럴까 어떻게 이미 있는 기술을 어떻게 디자인과 잘 인터그레이션하느냐가 빛을
발한 케이스지. 중요한건 저전력화시키는 하드웨어, 어떻게 유저인터페이스 빠르게
하느냐. 우리나라 삼성엔 그런 기술이 없어.

삼성 부사장 한명 외에
최적화 잘아는사람 아무도 없어
성격이 굉장히 쓰레기같아요
나하고 굉장히 비슷한데
어떻게 그 대기업에서 인간관계를 유지하고 살까 했는데
원래 삼성 60살 넘으면 다 짤리거든
근데 아직도 8년 넘게 삼성에 계셔
IBM에서 컴파일러 하시던분인데
타이젠 만드시는거야

내 자식들이 잘살으려면 너희(대학생)들 전투력을 증가시켜야돼

### Processor, CPU, and Core

* Core
  * Instruction을 실행하는데에 직접적으로 관여하는 하드웨어들을 몽땅 묶어서
    코어라고 부른다.
  * ALU, FPU, Private L1/L2 caches, ...
* Processor or CPU
  * 한개 이상의 코어를 모아, shared resources를 붙여놓은것.
  * 문맥에 따라 Processor는 하나의 코어가 들어있는 칩을 일컫을때가 많다.

### Uncore

A term used by Intel.

코어 안에 들어있지 않은 하드웨어 컴포넌트들 (QPI controllers, L3 cache, ...)

### Techniques to Improve a Single Core

* VLSI 기술이 발전할수록, 칩의 공간이 늘어나서 이것저것 넣을수 있게 되었음.
* On-chip caches
* Instruction pipeline

### Dependences (dependency)

```
디펜던시 깐다
옳게 배운사람들은
Dependences 라는 용어를 써요
무식하게 배운사람들이 Dependency라고 불러요

이트 무라우 (??)라는 무슨 대학 ㅁㄴㅇㄹ 누구의 스승의 누구가 소프트웨어 병렬화의
필요성을 피력할때 처음 dependences라는
용어를 썼어요.

그래서 이걸 써야돼
유식한사람들은
너넨 나한테 배웠으니까 이 용어를 써야돼
그래서 책이랑 논문들을 보면
멀티코어 하는사람들 계보를 알수있어
그리고 Dependency 같은 단어가 들어있으면 리젝시키는거지
ㅎ~ 넝담
(비순차 실행 설명으로 넘어감)
```

순서가 뒤집혀서 실행되면 안되는 어셈 코드들

* Flow (true) dependence
  * 순서를 바꿀 수 없는 디펜던시
* Anti dependence
  *
* Output dependence
  *
* Input dependence

##### Dependence removal

```
t := a + b
c := t + 3
t := 4 + d
f := t + 5
```

이렇게 코드가 있는데, 이름만 약간 바꿔도 인풋 디펜던시/아웃풋 디펜던시가 다
끊어진다.

```
t1 := a  + b
c  := t1 + 3
t  := 4  + d
f  := t  + 5
```

### Pipeline Decode Execute
Stage 5개를 만들어요

IF -> ID -> EX -> MEM -> WB

이걸 한칸씩 밀어서 실행해요

```
IF -> ID -> EX -> MEM -> WB
      IF -> ID -> EX -> MEM -> WB
            IF -> ID -> EX -> MEM -> WB
```

### Pipeline Hazard
* 다음 인스트럭션이 다음 클락 사이클에 실행되지 못하는경우
* Data hazard
* Structural hazard
* Control hazard

### Data hazard

(PPT에 아주 좋은 그림이 있음)

### Resolving Data Hazards

* Stalling the pipeline
* 파이프라인에 거품을 끼워넣어서 일부러 몇사이클을 낭비해서 순서가 원래대로
  돌아올때까지 실행을 늦춤

##### Software

일부러 nop 을 끼워넣음

##### Hardware

* Transparent register file
  * Write-back을 두단계로 만들어서
* (그 외의 방법 PPT에)

##### Structural Hazards

* 두 코드에서 동시에 서로 다른 메모리에 액세스해야할경우

##### Control Hazards

분기명령으로 인해 이 뒤에 실행할 예정이었던 코드들이 다 무의미해질경우.

### Branch Prediction

의외로 잘통한다.

* For문 돌떄 쓰는 조건문. For문이 긴 for문이면 조건문 결과가 거의 항상 비슷하게
  난다.

소프트웨어 소프트웨어 하는데 하드웨어 없으면 소프트웨어 성능 절대 못뽑아요.

### Out of order execution (OoO)

IF -> ID -> Resevation station -> EX / EX / ... / EX -> Reorder buffer -> WB

### Tomasulo's Algorithm

IBM 360/91

* Single issue

* In-order issue
* Out-of-order executiokn
* Out-of-order dispatch
*

이재진교수님이
Out-of-order exec 만든사람한테
이것들 용어의 정의가 너무 모호해서
가르치는데 힘들다고
저거 만든사람한테
막 얘기했더니
그사람이
꼬마들 가르치는데 그거 명확할필요없다
이랬다고함

보통 전기 많이 쓰면 안되는 ARM7 ARM9같은 애들은 그냥 in-order-exec 함.

그리고
SNUVM 만든 이야기가 나온다
내가 이거 만드느라 ARM 레퍼런스를 수도없이 읽고
집에안가고 그래서 막 집에서 쫓겨나고 그랬어
이거 기억땜에 내가 이제 ARM은 편해요

### Issuing and Dispatching an Instrucion

### Precise Exception
익셉션도 순서를갔다가 우리가 보존을 해줘야된다는거야. 페이지폴트가 났다고쳐봐.
그러면 실행 도중에 인터럽트가 걸린건데, Page를 갔다가 OS에서 가져오든지 새로
할당하든지 할텐데, 우리가 out-of-order exec를 했기때문에 폴트가 원래보다 더 먼저
일어날 수 있어.

그래서 폴트가 나기 전엔 명령어를 전부 실행하고, 순서를 정확하게 보존해줘야돼.

### Retirement (Graduation)
Reorder buffer에서 instruction이 사라지는경우.

* Instruction이 커밋을 했거나 (폴트, ..) (the result is made permanent)
* Instruction이 없어졌거나 (without making permanent change)

### Superscalar Processors
Vector Processor는 아니지만, 여러개의 값(스칼라)를 동시에 처리해서 슈퍼스칼라
프로세서.

OoO 할때엔 issue를 하나밖에 안했었음. 하나씩 차례대로 이슈를 했었음. 하나의
이슈로는 안됨. 이슈를 여러개를 동시에 할 수 있으면 더 빠를거임.

Instruction Fetch랑 Decode unit을 여러개를 둠.

Dynamically issue multiple instructions in each clock cycle
* 이슈할때도 인오더로 이슈한거랑, 아웃오브오더로 이슈하는거랑 나뉘는데,
    out-of-order issue가 더 우수함

ILP(Instruction Level Parallelism), 한번에 몇개의 명령어가 동시에 처리될 수
있는가, 한번에 몇개의 명령어가 동시에 이슈될 수 있는가.

보통 동시에 실행시키는 명령어 갯수가 2.8개로 멈춰있어서 ILP가 일정 이상 발전을
안하고있음.

우리의 현실. 프로그램상의 디펜던스때문에 이슈를 동시에 할수가 없음. 하드웨어를
아무리 잘 만들어놔도 소프트웨어가 익스플로잇을 못하면 그게 안됨.

그런 문제를 어디서볼 수 있을까? 여기(갤럭시 스맛폰)에서 볼 수 있지.

### VLIW Processors

Very Long Instrucion Word

디펜던시가 없는 인스트럭션들을 하나의 긴 인스트럭션으로 만들어주는거임.
하드웨어가 다이나믹하게 스케줄링을 안해줘도 알아서 고정된 갯수의 여러
인스트럭션들이 동시에 fetch, decode, issue, execute됨.

프린터 안에 VLIW 프로세서가 많이있음. 아이태니엄에도 이런거 들어있음. 처절하게
망했죠?

Static instrucion scheduling by a compiler

삼성이랑 엘지에 컴퓨터 아키텍처 할 줄 아는사람이 몇명이나 있을것같나? 10년전까진
0명이었어. 디자인 오토메이션은 이거랑 전혀 상관없는데 자꾸 이걸 건들라그래. 근데
삼성이랑 엘지엔 디자인 오토메이션(캐드)만지는사람밖에 없어.

우리나라 삼성에 컴파일러 만지는사람이 몇명이나 있을것같아? 0. 러시아에 외주나
주고앉아있고. 상무가 쥐뿔도 모르는놈이 나 불러서 자기자랑이나 하고 3.5억 주고
외주한걸 잘했다고 자랑이나 하고있더라고. 인간같지도 않은놈이 안짤리고 잘
살아있고. 아직도 우리나라는 기술을 잘하는사람이 아니라 인간관계 좋은사람이 더
잘나가.

우근이가 할수있는걸 왜 삼성이 안할까? 자신감이 없어서그래. 잘못건드렸다가 돈
시간만 날리고 망할까봐 그러는거지.

컴파일러 아키텍처 이거 다 맞물려있는거야. 밑에 시스템 이해 못하면 소프트웨어
백날 만들어봤자 아무 쓸모 없어.
