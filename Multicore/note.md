> 3월 4일

### Memory Wall

메모리 성능은 1년에 10%정도밖에 향상이 안됨. 그래서 60년대 말에 Cache라는
해결방법이 나옴, 아주 잘 쓰이고 있음.

연구를 하기위해서는 Practical 한 솔루션을 제시해야돼요.

멀티코어가 나오고 나서는 캐쉬 구조가 달라짐. ILP Wall과 파워 장벽은
멀티코어로극복했지만, 메모리 장벽은 멀티코어로 극복하지 못했지만 클락이 더
빨라지진 않을테니 오케이

### Programming wall

코어의 갯수가 늘어나도 프로그램이 바뀌지 않으면 의미가 없음.

멀티코어의 성능을 충분히 이끌어내려면 소프트웨어를 잘 병렬화시켜서 만들어야함.

멀티코어 붐이 일었을때 수많은 회사들이 있었지만 이제 IBM, SGI 밖에 안남음. 이
회사들이 왜 다 망했느냐? 몇십억짜리 시스템을 다 사놔도 프로그래머를 뽑기가
힘들어. 그래서 다 고철덩어리가 되는거야. 이게 지금까지의 문제

이게 굉장한 난제이다. 어떻게하면 이 장벽을 뛰어넘을 수 있을까?

### Programming model

응용프로그램을 개발할때 프로그래머와 병렬 컴퓨터 간의 인터페이스

여러분들이 프로그래밍 할때 하드웨어보고 하는거 아니잖아. 어떤 가상의 머신 위에서
하잖아? 그게 바로 프로그래밍 모델. 근데 우리 ILP Wall 전력장벽 해결 왜한겨?
성능해결하려고 한거지? 쉽게 프로그래밍 하게만들겠다고 성능을 잃어선 되겠느냐?
안됌. 근데 알다시피 쉽게 만드는거랑 성능을 최적화하는거는 서로 상충해. 쉽게
만드려면 추상화가 많이 필요하거든.

### 병렬 프로그래밍 모델의 종류

* 셰어드 메모리 패러렐 프로그래밍 모델
  - 오픈엠피
  - 피쓰레드
* 메세지 패싱 페러렐 프로그래밍 모델
  - MPI
* 엑셀러레이터 프로그래밍 모델
  - OpenCL
  - SnuCL
  - CUDA
  - OpenMP, OpenACC
* 옛 프로그래밍 모델에 안주하려는 경향이 있는 사용자를 기술발전의 추세에 맞게
    교육하는것이 중요

OpenMP는 굉장히 쉽게 만들어져있지만 실제로 써보면 성능최적화 이끌기 힘들어. 내가
직접 다룰수있는 여지가 적거든. 메세지패싱에선 MPI가 de facto 표준. 성능도
엄청나게 좋고 클러스터에 쓰기 적합하다. 그리고 이제는 Practical하게 쓰이는
가속기에 쓰이는 프로그래밍 모델들.

SnuCL은 OpenCL의 클러스터버전 내(이재진 교수님)가 만들었당. OpenMP 4.0은
엄청나게 많은 회사들이 밀고있고, OpenACC는 네개의 큰 회사가 밀고있다. OpenACC
한번 써봐요 얘 성능이 하나도 안나와. OpenMP는 미국 국립연구소 (로렌스랩,
등등)에서 써서 스탠더드가 됨. 근데 OpenMP 4.0은 스펙만 있고 구현체가 없어 (?)
3~4개월 안에 나옴. CUDA는 많이 쓰죠. 이게 제일 먼저 나옴. CUDA는 엔비디아 사유
프로그램이라 아무나 구현체를 못만듬. 그래서 OpenCL이 거기에 대항해서 나옴.
OpenCL은 GPU 안가리고 다 돌아가는데 CUDA는 엔비디아에만 들어감. 삼성 타이젠 삼성
시계에 들어가는 OpenCL 구현체 우리가 만든거임. OpenCL 로고도 애플이 가지고있음.
애플이 OpenCL 밀고 내부적으로 많이 사용하고있음. 지금 AMD, Intel이 많이
밀고있다. Intel과 nVidia은 원수간의 원수. 요즘 게임할떄 아니면 그래픽카드 써요?
온보드 그래픽카드 사요? 그거 다 CPU 안에 들어있는거. 인텔이랑 AMD가 APU 만들어서
엔비디아가 시장을 많이 잃었어. 그래서 예전에 인텔에서 논문 많이 쓰면 엔비디아
이름도 많이 나오고 그랬는데 요즘은 논문에서 엔비디아 상호도 못쓰게한다.

실제로 기술이 발전을 하면 뭐해? 사용자들이 배우기를 해야지. 옛날거에 안주하면
안돼. 프로그래밍 장벽을 극복하기위해 노력을 하자.

### 본 과목에서 다루는 주제

* 순차컴퓨터 시스템의 구조 및 소프트웨어의 동작원리
* 병렬성
* 병렬 컴퓨터 시스템의 구조 및 소프트웨어의 동작원리
* 가속기의 구조
* 병렬화, 벡터화, 동기화 방법
* 메모리 계층구조에 대한 최적화, 루프 최적화, 기타 최적화
* Ptheads
* OpenMP
* MPI
* OpenCL
* CUDA
* SnuCL

맨처음에 컴퓨터 파워 온 하면 어떤동작이 일어나나? 컴구나 시프나 오에스에서
안배웠나.

여러분 OS에서 베컨트 알고리즘, 데이컨트 알고리즘 배웠죠. 그거 텍스트북 틀렸어요.
그거 돌려봐. 안돌아가. **지금 세상에 나와있는 OS책 다 틀렸어.** 지금 멀티코어
아키텍처에서 그거 돌리면 그거 다 안돌아가. 상호배제할때 쓰는 동기화 방법 그거
실제로 C로 임플리먼트해서 돌려봐. 메모리 컨시스턴시 고려를 안하면 안돌아가.
그런것들 실제로 안되는거 이세상에 아는사람 몇명 안될거야. 30년전에나 잘되던
방법이야.

멀티코어에서도 캐쉬를 잘 다루는거 중요해요. nVidia 2007년도에 CEO가 서울대
방문한거 알아요? 좋은사람같던데 왜그러나 모르겠어. 아무리 회사라도
아카데믹한곳에선 그런짓 하면 안돼.

SnuCL은 OpenCL 같은 스펙에, 클러스터 위에서 돌릴 수 있도록 만든 새 구현체.
코딩을 새로 할 필요가 없다. AMD에서도 홍보해준다.

> Lecture 2

컴퓨터와 기수법
--------

### 컴퓨터

계산기. 내부 구조가 아주 복잡. 보통 블랙박스로 추상화. 추상화라는건 이제 우리가
관심없는건 신경안쓰고 관심있는 특성만 보자.

### 데이터

사전적 정의: 추론 논의, 계산의 기반이 되는 측정이나 통계에 의해 얻어진 사실적
정보

컴퓨터공학에선? 컴퓨터로 처리할 수 있는 형태로 구성된 사실적 정보

요즘 빅데이터 유행하지? 빅데이터에서 중요한게 뭘까. 빅데이터엔 중요한 세가지
특정이 있어요. 3V, 볼륨, 버라이어티, 벨로시티. 이게 중요해. 중요한건 분석방법.
통계를 이용해서 분석하지. 새로운 분석방법은 뭐 소셜베이스 외엔 별로 없고. 이건
새로운게 하나도 없는데 그냥 포장만 새로 한거야.

우리나라에서 빅데이터라고 할만한게 얼마나 많을까? 엑셀에 안들어가면 빅데이터라고
쳐봐. 엑셀에 16만로우까지 안들어가. 우리나라 전국민 건강보험 데이터가
300메가밖에 안돼. 이So

중요한건 데이터가 큰것보다 빠르게 처리하는거야. 데이터가 아무리 많아도
처리하는데에 한달이 걸리면 뭐하나? 처리하는동안 데이터 가치가 다날아가. 이걸
어떻게 빠르게 처리하느냐? 멀티코어야.

### 0과 1을 나타내는 전기신호

명확히 구분되는 두가지의 서로 다른 상태: 0과 1. 0.1볼트 근처는 0, 5볼트 근처는
1. 노이즈가 있어도 쓸 수 있도록.

### 하드웨어와 소프트웨어

* 하드웨어
  - 컴퓨터 시스템의 물리적 구성요소
* 소프트웨어
  - 여러개의 프로그램으로 구성된 집합
* 프로그램
  - 주어진 입력을 가지고 원하는 출력을 얻기위해 무엇을 해야하는지 컴퓨터에게
      지시하여 컴퓨터를 동작시키는 역할을 함

### 순차 컴퓨터 시스템

* 우리가 흔히 알고있는 시스템. 패러렐과 비교하여 이야기할떄 사용하는 용어.
* 하드웨어, OS, 어플리케이션 크게 세 요소로 추상화됨

### Application

* 응용소프트웨어. 줄여서 응용(어플)이라고 부름
* 사용자가 특별한 작업을 수행할때 도움을 주는 음용 프로그램의 집합

### 시스템 소프트웨어

컴퓨터 하드웨어를 운용하고 응용 소프트웨어를 실행하기위한 플랫폼.

ex) OS, CLI, Windows, Compiler, Debugger

### 유틸리티 소프트웨어

시스템 소프트웨어의 일종

컴퓨터 하드웨어와 소프트웨어를 관리하고 튜닝할떄 이용

ex) 백신, 압축프로그램, 파티셔너, 모니터, 어셈블러

얘네는 다 구분이 모호하다. 엄격하게 구분 못지어. 이거 구분하고있는놈들은
할짓없는 놈들이야

### r-진법

위치기반 기수법 (positional number system)

수는 숫자들을 연이어 나열한것으로 표현, 그 표현이 가지는 값은 각 숫자가 가지는
값을 더한것. 각 숫자의 값은 숫자의 위치에 따른 무게값에 따라 결정됨.

소숫점 (radix point)

수라는 개념은 절대적이야. 십진법, 십육진법 이런건 우리가 그 수를 표현하기위해
만든것들일 뿐이야.

### 흔히 사용하는 기수법의 기수와 숫자

이진법
팔진법
십진법
십육진법

여러분 팔진법은 요즘 잘 안쓰죠? 그리고 십육진법은 숫자가 모자라니까 알파벳 (A,
B, C, D, E, F) 을 쓰지.

기수법은 별로 안좋은게 이진수, 십진수, 팔진수 다 같은 숫자 (digit)을 써서 문맥에
따라 모호할떄가 있어. 이럴땐 명확하게 해주지

### Fixed-point repr

소수점이 어떤 위치에 고정되어있다고 가정. 소수점을 컴퓨터 내부에서 표시할 필요가
없음.

### 진수변환

이진수 -> 팔진수, 이진수 -> 16진수는 그냥 세개 네개씩 묶으면 된다.

### 십진 정수 N을 이진 정수로 변환하는 방법
### 십진 소수 N을 이진 소수로 변환하는 방법

### 정수부와 소수부가 조합되어있는경우

각부분을 따로 변환해서 결과를 조합

### 십진수를 8/16진수로 변환하기

십진수를 이진수로 바꾸고, 그걸 8/16진수로 변환.

### Unsigned integer

이진수가 0이나 양의 값을 나타낼 때.

n비트 언사인드 인티저 x의 범위: [0, 2**n)

### Signed integer

부호 붙은 수를 n개의 비트로 인코딩하는 방버

1.  부호붙은 크기 표현
1.  1의 보수
1.  2의 보수
    * 하드웨어 구현이 제일 간단함. 대부분의 컴퓨터가 사용중

옛날엔 1의보수, 부호붙은 크기를 다 썼지만 2의 보수가 제일 좋다. 제일 간단하다 =
트랜지스터가 적다 = 빠르다, 그 공간에 다른일을 할 수 있다.

### 보수

r진법으로 표현된 n개자리수 x의 r의 보수(radix complement, complement) 는

r**n - x (if x != 0)
0        (otherwise)

x의 (r-1)의 보수(diminished radix complement) x` 는

x` = r**(n - 1) - x;

### 보수 구하기

십진수 836의 (10 - 1)의 보수는 10**3 - 1 - 836 = 999 - 836 = 163

이거 쉬운 계산은 그냥 각 자리수를 (r-1) 에서 빼서 다시 조립하면 됨.

x가 0이 아닌경우, x의 (r-1)의 보수에 1을 더하면 x의 r의 보수를 얻을수있음

### 1의 보수 표현 === (2-1)의 보수

r=2일 경우에, (r-1)의 보수를 사용하여 음수를 표현하는것.

ex) 6의 b1의 보수는 (2**4 - 1) - 6 = 15 - 6 = 9
9는 b1001이고 (2-1)의 보수 표현에서 -6을 나타냄
2**3 을 안쓰는데엔 이유가 있음

MSB는 부호비트
1이면 음수, 0이면 양수

단점. 0을 표현하는 방법이 두개가됨.

0000 = +0
1111 = -0

### 2의 보수 표현

현재 대부분의 컴퓨터가 사용중

n비트 이진수로 표현되는 정수 x의 2의 보수

### 2의 보수 표현의 범위와 값

[-2**(n-1), 2**(n-1) - 1]

### (피피티 참고, 도저히 타자로 못치겠는 슬라이드. 피피티 볼것)

### Modular arithmetic, clock arithmetic

Euclidean algorith

두 정수 m과 n(!=0)이 주어졌을때, m = qn + r, (0<=r<|n|) 을 만족하는 유일한 정수
q와 r이 항상 존재함.

이게 우리가 아는 나눗셈하고 어떻게 다르냐? 음수일경우 다름

일반적인 경우: -7을 3으로 나누면 몫은 -2, 나머지는 -1
유클리디안: -7을 3으로 나누면 몫은 -3, 나머지는 2 (항상 양수여야하니까)

### mod

q := floor(x/m), m != 0

r = x mode m = x - mq, m != 0

m은 modulus 라고 불림

*   앞으로 이용할 성질

    ```
    (a+b) mod n = ((a mod n) + (b mod n)) mod n
    ```

보통사람들이 말하는 소프트웨어는 소프트웨어가 아니에요. 그건 SI야. 그건
전공불문이야 아무나 가서 하면 돼. 그건 컴퓨터과학이 필요하지 않아. 그건
소프트웨어 하는게 아냐. 그건 용역하는거야. 컴퓨터공학 하는데에 필요없는것들.
그건 대단할 놀러지가 필요하지 않아.

### 합동관계 (congruence relation)

나머지가 같으면 합동이다.

### 모듈로-m 연산 (modulo-m operation)

모듈러스가 m인 합동관계를 이용한 연산

m개의 수 0, 1, 2, .. , m - 1을 연산에 이용

예) 모듈로-8 덧셈

1 + 4 === 5 (mod 8)
8 + 5 === 5 (mod 8)
7 + 3 === 2 (mod 8)
0 + 8 === 0 (mod 8)

내가 오늘한것들은 중학생한테 가르쳐도 다 할거야. 중요한건 이 숨은뜻을
이해하는거야.

--------

Lecture 03

부울 대수와 조합 논리회로
--------

*   1854년, George Boole
*   두개의 원소를 가진 집합 {0, 1} 을 정의하고, 이 집합에 대해 정의된 세
    논리연산 AND, OR, NOT 을 만듬
*   클라우드 섀넌의 논문에 베이스를 두고있음. 이때 섀년이 쓴 Information
    Theory가 지금 컴퓨터의 근간을 이룸.

### 부울 식

상수 0과 1, 변수, 논리연산자 and or not 을 포함하는 심볼들로 구성된 문자열.
부울식은 귀납적으로 정의됨

1. 심볼은 부울식
1. exp가 부울식이면 ~exp 도 부울식
1. e1, e2가 부울식이면 (e1 && e2), (e1 || e2) 도 부울식

### 곱셈항과 민텀

*   term, 항

    불 식에서 `+` 로 나뉜 각 부분을 항이라고 함

*   literal, 리터럴

    부울 식에 나타나는 변수 자체 (x)나 변수의 부정 (~x)

*   product term, 곱셈항

    리터럴의 AND 연산만으로 구성되어있는 항

*   minterm, 민텀

    n개의 변수를 가진 부울 식에서 각 변수에 대한 리터럴이 '한번씩만' 나타나는
    곱셈항. 한번씩 다 나와야됨

    예를들어 x, y 두 변수에 대해 나올수있는 모든 민텀은

    - ~x * ~y
    - ~x * y
    - x * y
    - x * y

### 부울 대수의 공리, Axiom

Axiom? 무조건 참이라고 믿는 / 가정하는 논리체계의 기반, 바닥.

* 집합 `B = {0, 1}`에 대한 부울 대수는 여섯 개의 공리를 가짐

1.  B에 속한 모든 x와 y에 대하여 x + y 와 x*y 도 B에 속한다.
2.  B에 속한 모든 x에 대해 x + 0 = x, x*1 = x 를 만족하는 서로 다른 원소 0과 1이
존재한다.
3.  B의 속한 모든 x와 y에 대하여 x + y = y + x, x\*y = y*x
4.  배분법칙
5.
6.

### 부울 대수의 정리, Theorem

* 공리를 이용하여 부울 대수에 관한 여러개의 정리를 증명할 수 있음

B에 속한 모든 x, y에 대하여..

1.  x + x = x, x*x = x
2.  x + 1 = 1, x*0 = 0
3.  (x + y)\*x = x, (x*y) + x = x
4.  (x + y) + z = x + (y + z), (x\*y)*z = x\*(y\*z)
5.  ~x 는 유일
6.  ~(~x) = x
7.  ~(x + y) = ~x\*~y, ~(x*y) = ~x + ~y

### 정리 1의 증명

진리표로 증명함.

사실 5번 빼고 다 진리표 쓰면 됨

### 정리 3의 증명

진리표 안쓰고 공리 쓰면 됨

```
  (x + y)*x
= x*(x + y)
= (x + 0)*(x + y)
= x + (0*y)
= x + (y*0)
= x + 0
= x
```

Term rewriting system을 쓰면, 정리 증명을 자동으로 할 수 있다. 프로그램을 짜면
'이 프로그램에서 이 시점은 x는 항상 1이다' 이런것도 Theorem prooving 기계로 함.

### Boolean function

B = {0, 1} 일때, n개의 변수 x1 x2 .. xn 을 가진 부울 식은 부울 함수 f: B^n -> B
를 정의함

n개의 변수를 가진 서로 다른 부울 함수는 총 2^(2^n) 개

### Functional Completness (함수의 완전성)

어떤 논리연산의 집합에 든 연산만으로 서로 다른 모든 부울 함수를 정의할 수 있으면
그 집합은 Functionally Complete 하다고 말함.

* 어떤 불 함수라도 AND, OR, NOT 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 XOR 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 XNOR 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 NOR 의 조합으로 정의할 수 있음
* 어떤 불 함수라도 NAND 의 조합으로 정의할 수 있음

### 진리표를 부울 식으로 변환하기

*   부울 함수를 부울 식으로 쓸수만 있으면 회로로 만드는 과정은 정말 쉽기때문에
    이런 과정이 필요함
*   n개의 리터럴을 가진 민텀과, n개의 변수를 가진 진리표에 존재하는 입력 값의
    조합은 1:1 대응. n개의 변수를 가진 진리표의 한 Cell은 모두 n개의 리터럴을
    가진 민텀으로 표현 가능하다는 이야기
*   민텀은 대응되는 입력 값의 조합에 대해서만 1이 됨.
*   진리표에서 함수의 결과 값이 1이 되는 입력 값의 조합에 대응되는 민텀을 모두
    구하고, 이들을 OR 연산으로 묶으면 진리표를 부울 대수로 만들 수 있음.

* 반 가산기
  * 두개의 입력 비트 x, y를 더하고, 그 결과로 두개의 비트 s와 c를 출력하는
    전자회로

### 부울 식의 간소화

Karnaugh map

### 로직 게이트

부울대수는 논리회로의 수학적 모델링, 로직 게이트는 이것의 물리적인 구현

*   Propagation Delay

    전달 지연

*   게이트 딜레이

    게이트 하나 통과할때마다 1ps정도 작은 딜레이가 생김

    ```
    <@p> 45~65nm에서 온오프 걸리는 시간이 ps
    <@p> 1ㅔㄴ
    <@p> 1ps
    ```

### 기본적인 로직 게이트

이름  | 트랜지스터 수
------|---------
NOT   | 2
OR    | 6
AND   | 6
NOR   | 4
NAND  | 4
XOR   | 14
XNOR  | 12

### 로직 게이트의 함수적 완전성

*   Universal gate

    Universal gate 하나만으로 모든 부울 함수를 구현할 수 있음

### 로직 다이어그램

Schemetic

### Bus

옴니버스에서 나온 말. 동시에 전기신호가 전송되는 두개 이상의 연관된 와이어들로
이루어진 집합. 버스 내 각 와이어가 한 비트의 정보를 전송함

*   Word

    컴퓨터에서 하나의 단위로 취급하여 처리하는 서로 관련된 비트들의 묶음.
    일반적으로 하나의 워드 안에 든 여러개의 비트들을 동시에 처리하도록 컴퓨터
    하드웨어가 구현되어있음

### Tristate buffer

로직게이트는 아니지만 비슷한 역할을 하기때문에 쓰임

함수표(function table)는 진리표를 압축하여 더 간단히 나타낸것

조합 논리회로
--------

Combinational logic circuit

*   로직 게이트들을 와이어로 연결한 회로, 항상 현재의 입력값들에 의해 그 출력
    값이 결정됨.
*   여러개의 입력과 여러개의 출력을 가짐
*   각각의 출력은 하나의 불함수로 표현됨

### 멀티플렉서

*   셀렉터, MUX
*   2^n개의 입력과 n개의 선택 비트가 들어옴, 한개만 선택되어 출력됨
*   2-to-1, 4-to-1, 16-to-1 멀티플렉서

### 디코더

*   Demultiplexer
*   n개의 입력비트에 대해 최대 2^n개의 출력을 가질 수 있음
*   2-to-4, 3-to-8 디코더
*   enable 입력을 가질때도있음

### 디코더를 이용한 MUX 구현

2-to-4 디코더를 이용해 4-to-1 MUX 를 구현할 수 있음

--------

> 3월 11일

조합 논리회로만으로 ALU (기본 계산의 단위) 다 만들수 있음. GPU에도 이 벌겨 아닌
ALU가 수천개씩 들어있음. 하지만 이걸로 메모리는 커버 못함.

순차논리회로는 메모리와 관련이 있음.

책에 그림 자동으로 배치하는 알고리즘이 아직도 난제임

순차 컴퓨터 시스템 제대로 설명하려면 200~300p 나올거임. 그거 하고나면 컨텍스트
스위칭, 컨커런시에 대해 배울거임. 베이컨스 알고리즘 이런거 다 안돌아간다.

컨커런시에 대한 기반이 없으니, 순차컴퓨터 시스템부터 기반을 아주 잘 잡아놔야됨.
근데 이 쉬운 개념을 생각을 안하고 자기것을 못만드니 기본이 안되는거임.

베이컨스 알고리즘 이런거 다 안돌아가요
캐시 끄고해도 안돌아가
논캐시어블 해도 안돌아가
메모리 컨시스턴시가 보장이 안돼서그래
그거 OS 책쓴사람이 몰라서그래

멀티코어시스템을 공부하려면 싱글코어시스템을 잘 알아야돼요
공부하기 얼마나 편해 그지
이것만 보고 배우면 돼요
여러분들은 기니피그여
너 동물이야 아냐
동물이지
포유류 안의 영장류지
knuth

마이크로소프트 워드로 쓴거에요
레이텍으로도 써봤는데
워드가 더 편해요

아래아 한글에서 이미지 프로세싱하는걸 좀 빠르게 해달라고 막 그러고있는데
워드로 쓰고있어요
knuth 이분이 논문 출판할때 마음먹은대로 안돼서 Tex을 개발했어요.
이걸갔다가 쓰기 어려우니까 레이텍이라는걸 만든사람이 Lamport 라는 사람이에요

knuth 이분은 수학관련 논문이면 변하는게 없어요
어떻게 하면 멀티프로세서 시스템에서 여러개의 프로세스가 correct하게 돌아가는
그런걸 이야기한사람이 lamport에요
안돌아간다 이거야
이사람도 이걸 만들어서 사람들을 굉장히 이롭게 했어요
그게 연구에요 연구
연구를 하면 사람에게 practical하게 도움이 되게 해야지

아주 fundamental하게 그런것도 도움이 되는게 많아요
 여러분 물에 대해 얼마나 알아요
 화장품이 뭐냐
 물 + 기름이에요
 왜 이런얘기를 하느냐
 들어보라고 한번
 기름에다가 물을 넣는거하고 물에다가 기름을 넣는거하고
 성질이 달라져요
 이게 뭐겠어요?

기름을 까뜩채워
그리고 여기다가 계면활성제를 넣어요

그리고 물을넣어
그게 여러분 바르는 연고있지?
그거에요

로션같은거는 물에다가 기름활성제를 넣어서 기름을 넣는거야
이게 애멀젼이에요 애멀젼

ㄱㄴ데 왜 이렇게 되는가가 원리가 규명이 안되어있어
그래서 물에다가 기름썪은건 바르면 시원해요
근데 기름에 물 섞은건 바르면 끈

난 이런걸 왜 해봤을까?
그러게요
여러분이 냉각을 하죠
근데 써버를갔다 냉각을 하는데
근데 수냉식으로 쿨링하다가
이거 터지면 어떻게돼요?
정xxxx이가 이거 한순간의 실수로 3000만원 날렸어
물때문에
응?
과냉각을 시키면 어떻게돼요
그러면 공기중에 구름이생겨
그러면 3000만원 날라가는거야
18도 이하로 서버실을 과하게 춥게만들면 안돼
근데 우리는 5도로 했거든

그래서 날라간거야
근데 기름을갔다가 쓰면
기름은 이런 위험이 없는데
열전도성이 5배 나빠요

근데 우리가 기름에다가 물을 섞으면 비전도성이 유지가 되면서 점도가 굉장히 높아지고 열전도성은 물처럼 좋아져

그래서 내가 화학 실험실에 갔다가 이걸 했어
그래서 이게 됐을까 안됐을까
안됐어 (?)
내가 이거 하려고 논문을 많이 읽어서 기계공학과 논문도 많이 읽어봤는데 별거아니더라구
그래서 그냥 기름으로 했어요
기름이 어떤 기름이겠어요?
미네랄 오일이라고
존슨즈 베이비오일
한말에 오만원 주면 사
이거 하면서 실험에 막 얼굴에 발르니까
보습효과가 있어서
피부가 좋아지더라고
음식에도 들어가요
(멀티코어 수업임)
보통은 미네랄오일 있으면 서버를 그냥 거기다가 담궈버리는데
그러면 귀찮아
서버실이 온 기름천지가 된다고
우리가한건 방열판 안에 기름을 흘려서
터져도 문제가 없지
고런 장점이 있지
거의 세계 최초라고 할수있지
(멀티코어 수업임)
내가 이걸 옆 연구소에 많이 홍보했지
이게 많이 좋은데 대신 방열판이 튼튼해야돼
이게 컴퓨터를 잘 몰라도 상식으로 하는거야
연구란게 원래 그래요
옆길로 이야기가 많이 샜네
순차논리회로가 그래서

순차 논리회로
--------

순차논리회로는 클락을 가짐. 현재의 입력값 뿐만 아니라, state를 갖고 이전
입력값에 영향을 받음.

순치 논리회로 = 조합 논리회로 + 메모리

동기 순차 논리회로, 비동기 순차 논리회로로 나뉨

### 클락

일정한 간격으로 rising edge, falling edge가 생김.

### 랫치 & 플립플랍

우리나라 책들이 이게 아주 헷갈리게 써있어.

커뮤니케이션이 반이야.
앞으로 사회 나가면 소통
생각을 한다음에 남한테 설명하는게 반이라고
남 한번 가르쳐봐요 엄청나게 공부 많이해야돼

메모리는 보통 플립플랍으로 구현됨.

*   하나의 플립플랍은 한개의 비트를 저장
    * 두개의 구분 가능한 상태
*   플립플랍은 보통 랫치로 구현함
    * ..

**플립플랍과 랫치의 차이**

### SR Latch

두개의 입력 Set과 Reset, 두개의 출력 Q와 Q\`

`S = 1 && R = 1` 이 아닌이상 항상 `Q\` = ~Q` 를 만족함

S | R | Q
--|---|---
0 | 0 | Q_prev
0 | 1 | 0
1 | 0 | 1
1 | 1 | *undefined*

`S = 1 && R = 1` 이면, Q가 0과 1로 반복적으로 바뀌는 불안정한 상태에 이름. 허나 그 값이 1이 될지 0이 될지 예측할 수 없음

이걸로 1 비트를 저장할 수 있음

### D Latch

데이터를 지정하는 입력 D

새로운 입력을 받아들일지 말지를 제어하는 입력 C

C = 1 일동안 랫치의 출력이 입력 D에 따라 바로 바뀜

No undefined state

C | D | Q
--|---|---
0 | X | Q_prev
1 | 0 | 0
1 | 1 | 1

### D 플립플랍

D 랫치 두개를 달고, 클락을 달아줌. Rising Edge에서 D를 저장

### Master-slave D flipflop

(멋진 time 다이어그램)

D가 무작위로 주어졌을떄
Q_master는 클락이 0일때 (클락이 마스터를 활성화시킬때)만 입력을 받고
최종 Q (=Q\_slave)는 클락이 1일때 (클락이 슬레이브를 활성화시킬때) Q_master의
입력을 반영받음

플립플랍: 클락이 Rising edge 일때의 입력 D를 저장하여, 출력하는것이 플립플랍

랫치: 그냥 마지막 입력을 저장하여 출력하는것이 랫치

### Register

한번 정보를 저장하면, 입력이 바뀌어도 정보가 계속 유지되는 장치.

(그림)

이게 개념적으로 이런식으로 작동한다는거지 실제로 이렇게 만드는건 아님

### 1-bit register

(멋진 time 다이어그램)

Load signal이 1이고, rising edge인순간 그 값을저장함.
Load signal이 0이면, 입력이 뭐가 되든 저장된 값이 유지됨.

### Counter

Rising edge마다 숫자가 1씩 증가하는 N-bit register.

Modulo-4 counter. Program counter

프로그램 카운터가 모에요
컴터가 다음으로 실행할 인스트럭션의 주소가 저장된 레지스터요
모에모에큥
그럼 카운터가 몇씩 늘어요
워드단위로 늘어요 (RISC 기준. 요즘 CISC는 추세랑 안맞아서)
워드가 모에요
컴퓨터가 기본으로 처리하는 정보의 단위요

### State table

입력, 출력, State간의 시간에 따른 관계를 나타냄

modulo-4 counter의 state table은 아래와 같음

### FSM

동기식 순차 논리회로는 FSM과 1:1 대응됨.

### Mealy FSM

출력 함수 H가 현재상태와 입력의 함수일때, 즉 H:S X I -> O

### Moore FSM

출력 함수 H가 현재상태만의 함수일때, 즉, H:S -> O

### FSM의 구현

출력 함수 H와 다음상태를 정의하는 전이함수

### Random Access Memory

컴퓨터에서 주로 쓰는 메모리. 이진 정보가 RAM에 워드 단위로 저장됨.

워드가 액세스되는 순서 없이 워드를 읽거나 쓸때 동일한 시간이 걸리는 메모리를
뜻함. 램 내 워드의 위치는 접근속도에 영향을 미치지 않음

RAM의 용량 또는 크기 = 저장할 수 있는 총 비트의 개수

RAM의 구성
*   워드의 갯수 * 비트로 나타낸 워드의 크기

### RAM Cell

Data\_in, select, write가 입력으로 들어오고 Data_out이 출력으로 나감

RAM 여러개를 CS(Chip Select)비트로 또 동시에 여러개를 조종함.

### 큰 용량의 RAM 구현하기

Word를 냅두고 칩을 늘려도 되고, Word를 늘리고 칩을 냅둬도 됨

## RAM의 액세스

전파지연(propagation delay)때문에 타이밍 관련 이슈가 많음.

1.  Addr 입력을 주면 아웃풋이 나오는데, 데이터가 불안정함. 데이터가 제대로
    출력되기까지 시간이 필요함
1.  유효한 주소를 넣기 시작한 순간부터, 유효한 데이터가 처음 나오기까지의 시간을
    메모리 액세스 시간(Memory Access Time)이라고 함. 보통 60~55ns 걸림
1.  이 이외의 상태에서는 tristate buffer가 끊어진 상태(하이 임피던스) 상태로
    존재함.

쓰기도 비슷함.

### DDR2, DDR3, DDR4

### Assignment

DRAM에서, DDR2, DDR3, DDR4 각각이 무엇을 의미하는지 조사를 해오기. LPDDR3, LPDD4
(Low power, 서너배 비쌈) 이것도 조사해와.

--------

연구는 실용적으로 해야돼

우리나라 대학 50개만 남기고 싹 정리해버려야돼

대학에서 놀면 안되죠? 죽도록 시켜야지 공부를

국민의 세금을 응 그렇게 써서 돼?

내 애들이 잘사는 세상을 만들려면 여러분 교육을 잘 시켜야돼. 내 애들이 아직
어리단말이야.

내가 외과의를 하고싶은데 나이가 들면 못할거같아.

요즘들어 난 땡기는게 그거야
외과 들어가서 수술 한번
손으로 한번

외과 수술을 하려면
눈도 좋아야하고
손도 안떨려야돼
근데 15년 후엔 떨려야할거야


짜릿하잖아
하나 끝내고나면

응급실에 있으면 계속 짜릿하겠지
나: 교수님 혹시 허트로커라는 영화 아시나요

나: 거기 주인공도 그 짜릿함때문에 폭탄해체반을 제대를 못하고 계속 군복무를
하는데요
폭탄해체는 하기싫어
난 고등학교때 우리나라에선 골프 안치겠다고 평생 결심했어

그리고 한국들어와선 평생 골프 손 안대고있어요
골프장 만드는건 우리나라엔 백해무익해
운동하고싶으면 탁구를 치지

확실하게 배워서 간다 이렇게 생각해야돼

이진 정수의 연산
--------

### 이진 정수의 시프트 연산

Logical shift (>>)

Arithmetic shift (>>): 빈공간을 MSB로 채움. 부호비트 보존

### 시프트 연산과 곱셈, 나눗셈

2의 거듭제곱 곱하는걸 시프트로 표현할 수 있음.

부호없는수에 8 곱하고싶으면 그냥 << 3 하면 됨.
2의 보수도 똑같음. -3에 <<3 하면 *8 이랑 똑같음

오른쪽으로 시프트하는것도 나눗셈. /8 하고싶으면 >>3 하면 됨. 근데 유클리디안
디비젼임.

-7을 4로 나누면 -7 = 4\*(-1) - 3이 아니라, -7 = 4*(-2) + 1. 실제로 -7 에서 >>3
하면 -2 나옴. 근데 C에서 나눗셈하면 유클리디안이 아니라 우리가 아는 나눗셈이
나옴.

### C 언어의 시프트 연산

오른쪽시프트와 왼쪽시프트 연산을 지원

C99 표준은 음수에 대한 오른쪽 시프트를 정의하지 않음. 컴파일러 디펜던트임.

### Sign extension

작은 자리수의 2의 보수를 큰 자리수로 늘릴떄, 생기는 빈 공간을 MSB로 채우기. 그게
바로 사인 익스텐션

### Unsigned int의 덧셈

더해YO. 오버플로우 생기면 자르고 오버플로우 비트에 표시하면 돼.

n비트 unsigned int 의 덧셈은 module n**2 연산을 수행하는거랑 같음.

### 2의 보수 표현의 덧셈

그냥 unsigned int라고 생각하고 무식하게 더한다음에 계산 다 하고 2의 보수
표현으로 읽으면 됨.

왜 `1 + 1 = 2` 인가? Peano arithmetic.
http://en.wikipedia.org/wiki/Peano_axioms

##### Overflow

2의 보수는 오버플로우 체크가 조금 특이함. 덧셈을 계산할때 MSB로 들어가는 carry랑
MSB에서 나오는 carry랑 다르면 오버플로우임.

### 전가산기 & 반가산기

반가산기

x,y를 더해서 합 s와 carry 출력

전가산기

x, y, c\_in을 받아서 합 s 왜 c_out 출력

하프애더 하나와 전가산기 n-1개로 n비트 가산기를 만들 수 있음

unsigned int, signed int의 덧셈 하드웨어는 오버플로우 감지만 다르고 다 같음.

### 이진 정수의 뺄셈

Unsigned

걍 무식하게 하면 됨

2의 보수

x - y = x + (-y) = x + y' + 1

반감산기, 전감산기

n비트 adder 살짝 바꾸면 n비트 subtracter 만들수있음 (x - y = x + y' + 1)

### 부호 없는 수의 곱셈

십진수 곱셈이랑 같은 원리로 함.

근데 회로도 그렇게 짜느냐? 망함

시프터랑 덧셈기 여러개로 곱셈기 만들수도 있음.

곱셈. 진리표를 부울 대수로 펴서 연산자 갯수를 제일 줄여서 이걸 해보자.

CPU 만드는건 쉬워
성능이 안좋아서 그렇지
그얘기 해줄까?
지루할거같으니까
에테아라는게 있죠
ETH
아인슈타인 나온데에요
스위스 연방대학
스위스에서 제일 좋은학교인데
여기에 니콜라스 wirth라는 사람이 있어
늙어서 80이 생겼는데
치매끼가 있는거같애
늙어서 치매가 안올라며
담배를 많이펴야돼
치매 걸릴 기회가 없으니 치매를 안걸리시겠죠 교수님
PASCAL 만든사람이야
프로시져 랭귀지 만드는
이거 공로로 튜링 어워드를 만든 사람이에ㅛ
이걸가따 쪼금떠 발전을 시킨게
Oberon 랭귀지를 만들어서 거기선 이제 학생들 만들땐 이걸 쓰고
Oberon OS 도 있어
Oberon 프로세서도 있다고
그래서 거기엔 C랑 C++을 안가르쳐
미친놈들
Oberon에 OOP 개념도 있어
이야기하는 이유가
여러분들 별로 어려운게 아니라고
CPU 디자인하는거
다 할수있어
다만
테이프아웃하고 최적화 하는거
트랜지스터 뭐 수도없이 많이써도 얼마 들지도 않을거고 최적화 안하면 만드는건 쉬워
OS 만들어서 얹고
컴파일러 만들어서 얹고
한명이면 할수있어
엣날에 그런생각을 했는데
학부 1학년 2학년한테
과목을 4개를 연달아서 해서
CPU -> OS -> 컴파일러 다 만드는걸 해서
학생 1인당 1 컴퓨터를 만들게하는걸
생각을했어
다른학교에서 굉장히 2년연속해서 버클리에서 이런식으로 한번 했었어
여러분 이렇게 하면 배우는게 굉장히 많 다고
여러분 이런 경험 한적 있어요?
너 OS 들었니
너 OS 만들어봤어
나: 아니요
OS 안들었어?
아직이요
왜안들었어
아직 들을 나이가 안됐어요
너 15학번이야
13이요
너 몇학년이야
2학년이요
1년 휴학했어요
근데 이건 왜들어
\>ㅅㅇ
(?)

이런건
납땜하지말고
FPGA로 만들면
여러분도 쉽게 CPU 만들수있어요
얼마나 좋아

### 부호 없는 이진수의 나눗셈

십진수의 나눗셈과 원리가 같음

나이브하게 구현하면 아까꺼랑 똑같음 대신 MUX가 좀 많이 들어감. 복잡함..

### 2의 보수의 이진수 나눗셈

```
resut := x / y
```

left, rigth 의 부호를 잘 조작하면 됨.
유클리디안 나눗셈 말고, 우리가 아는 나눗셈은 부호 떼버린다음 나눗셈하고 나중에
다시 부호를 붙이면 됨.

줜내복잡함.

빠르게 나눗셈하기: http://arith.stanford.edu/~hung/papers/asilomar.pdf

시험문제는 어떻게 낼거냐
이걸 구체적으로 물어볼건 아니고
이걸 어떻게 하는가 설명을 시킬거야
그러니 이걸 이해를 해야돼
아까 디비젼 하는 진리표를
논리게이트로 옮긴거뿐이야

--------

> 3월 18일 수요일

부동소수점
--------

### 과학적 표기법
m * b^e

m: mantissa
e: exponent
b: base

### 정규화된 과학적 표기법
m의 범위를 [1, b)로 한정시킴

이렇게하면 0 외의 모든 수는 표현할 수 있음


### 부동 소수점 표현

### IEEE 754
1985년에 제정됨, 2008년에 IEEE754-2008로 개정됨

1.  32, 64, 128비트 - 세가지 이진 부동소수점 기본형식
1.  십진 부동소수점
1.  Extended precision format - 확장 정밀도 포맷의 기준. 80비트짜리

### IEEE 754 이진 부동소수점 표현
* 32: 단정도
* 64: 배정도
* 128: 사배정도

sign 비트 1개
E 비트 w개
F 비트 k개

1+w+k = n

case                     | kind
-------------------------|-----------
E == 00..0, F == 0.00..0 | +-0
E == 00..0, F != 0.00..0 | 서브노멀 값
E != 00..0, E != 11..1   | 정규 값
E == 11..1, F == 0.00..0 | +-INF
E == 11..1, F != 0.00..0 | NaN

### 라운딩
* 어떤 실수는 그 값은 IEEE 754로 정확하게 표현할 수 없음
  * 그 수에 가장 가까우면서 부동소수점 표현으로 표현할 수 있는 값으로 어림잡아 표현
* Rounding: 더 적은 수의 자릿수를 가진 값으로 주어진 수를 어림잡는 작업
* Rounding error, Round-off error: 원래의 값과 라운딩한 값의 차이

* Round to the nearest, ties to even
* Rount to the nearest, ties away from zero
* Round towards +INF, rounding up, ceiling
* Round towards -INF, rounding down, floor
* Round towards -INF, truncation

floor와 truncation의 차이? 음수

70년대엔 1달러가 꽤 큰돈이었는데, 그당시에 책 앞머리에 틀린말 있으면 1달러
이러곤 했음

### 이진수의 라운딩
이진수의 경우도 십진수와 같은 규칙을 적용할 수 있음

표준에 내정된 라운딩 규칙: Round to the nearest, ties to even

### 정규 값
Normal value, Normalized value

E != 00..0, E != 11..1 일때

v = (-1)^s * m * 2^e, 1 <= m < 2

소수부 F의 왼쪽에 암묵적인 1과 그 사이에 소수점이 존재함을 가정

0 ~ 1000 1100 ~ 1011 1111 1010 0100 0000 000

일때

e = E - bias = b10001100 - 127 = 140 - 127 = 13
m = 1 + f =

##### 고정소수점에서 IEEE 754로 바꾸기

```
  103.625
= b1100111.101
= 1 * b1.100111101 * 2^6
=
```

```
  -3.141595 * 10^10
= -1 * b1.110101000010001001010110101011 * 2^32
 (round to nearest even)
= -1 * b1.11010100001000100101011 * 2^32

0 | 0010 0000 | 1110 1010 0001 0001 0010 101
```

### 서브 노멀 값
Subnormal value, Denormalized value

E = 00...0, F != 0.00...0

v = (-1)^s * m * 2^(1-bias), 0 < m < 1

m의 값은 소수부 F의 값을 f라 할 때, m = f

서브노멀 값은 소수부의 바로 왼쪽에 소수점을 가정하나 정규값처럼 암묵적인 1을
가정하지 않음

```
  2^(-149)
= 1 * 0.00000000000000000000001 * 2^(1-127)

0 | 0000 0000 | 0000 0000 0000 0000 0000 001
```

### 오버플로우와 언더플로우
서브노멀 값, 0은 언더플로우로 취급

+INF, -INF는 오버플로우로 취급

### INF
E = 11...1, F = 0.00..0

IEEE 754엔 무한대에 대한 연산도 정의되어있음

n / INT = 0.0
-n * INF = -INT

+INF 는 모든 정규값, 서브노말값보다 큰것로 정의됨
-INT 는 모든 정규값, 서브노말값보다 작은것으로 정의됨

### NaN
Not a Number

E = 11...1, F != 0.00...0

계산의 결과값을 나타낼 수 없을때 사용 (`0/0`. `sqrt(-1)`, ...)

NaN이 들어가는 비교연산은 `NaN != NaN`만 true이고, 그 외엔 무조건 다 false임

### x86 80-bit extended precision
Intel의 80x87 계열의 부동소수점 Coprocessor를 위해 처음 제안되었고, 그 이후 x86
아키텍처의 부동소수점 연산장치에서 계속 사용함

바이어스된 지수의 바이어스는 16383
실제 지수 e는 E-16383 으로 계산됨

얘는 암묵적인 1이 없고, 비트에 1로 표현되어있음

* QNaN
* SNaN
* undefined
* normal values
* subnormal values
* pseudo-denormal values

1 | 100 0000 0010 0001 | 1 | 1101 0100 0010 0010 0101 0110 1010 1100 ...

익셉션이 모야. 트랩이랑 폴트 그거 다 비슷한거야

### 부동소수점 연산

교환법칙 commutativity
결합법칙 associativity

* 실수의 덧셈은 교환법칙과 결합법칙이 성립
* 라운딩때문에 덧셈, 곱셈 결합법칙은 성립 안함

점점 커지는 숫자 여러개를 더할때 작은것먼저 더하는게 나을까 큰것먼저 더하는게
나을까? - 작은거 먼저 더하는게 나음.

### 부동소수점 표현의 덧셈과 뺼셈
* 뺄셈은 음수취해서 덧셈하면 됨
* 먼저 지수가 더 큰수의 소수점에 맞춰서, 두 수의 지수를 일치시킴
* 가수를 더함
* 가장 가까운 짝수로 라운딩

### Round-off error
```
x = (-1)^s * m * 2^e, 1 <= m < 2

|m_r - m| <= 1/2 * 2^(-23)

|x_r - x| / |x| <= 1/2 * 2^(-k)
```

라운드 오프 에러의 상한을 정할 수 있음. 이를 엡실론, 유닛 라운드오프라고 함.

엡실론 다 배웠지
(나) 넹
칼큘러스할때 다 가르치나
(나) 넹
이해했어?
(나) 넹
이해했다고 느낀건 아니고?
(나) 사실 둘이 구분하기 어렵지 않나요
몰라
그거 수학과 3학년도 이해하면 대단한건데

### 부동소수점 표현의 곱셈
곱셈이 더 쉬움 (지수 맞추는 과정이 생략됨)
부호는 곱셈 하고 따로 수행

### 부동소수점 표현의 나눗셈
지수끼리 빼고, 가수끼리 나눠서 수행.

### Fused Multiply-Add
`x*y + z`를 한번에 수행할 수 있음

FMA 연산을 수행하는 특별한 연산장치
* FMA 연산을 위한 머신 인스트럭션을 제공
* 요즘 대부분의 CPU/GPU가 이를 제공
* 컴파일러 옵션 주면 이거 쓸 수 있음

FMA가 유용한 경우

* Dot product
* 행렬곱
* 다항식의 계산 (묶어서)

속도뿐만 아니라, 정확도도 높아짐 (라운딩을 한번만 해서)

### 반올림을 안하고 nearest even으로 간 이유
더 공평해서? 하드웨어를 만들기 쉬워서? 몇년간 논의가 있었긴 했을거임

### 96, 128 비트가 아니라 80비트를 쓴 이유?
80비트로 하면 F가 64비트로 딱 떨어져서 계산하기에 좋았었음

--------

> 3월 23일

암호를갔다가 해독하는 작업인데 어떻게하면 빠르게할 수 있느냐
내가 하는거랑 앨런튜링이 하는거랑 뭐가 다를거같아
앨런 튜링은 암호 해독 체계를 발견한 사람이고
나같은경우는 무식하게 빠르게
예를들면 패스워드를 알아낸다
제일 쉬운방법이 모에요
몽땅 다 트라이해보는거야
그럼 빨라야될거아냐
원래 컴퓨터라는게 뭐하는거에요?
단순 작업을 무식하게 빠르게 하는게 컴퓨터야
AI, 머신러닝
별거있을거같지
별거없어
안그러면 뭐
그게 안돼요
그냥 빠르면 장땡이야
단순 작업을 빠르게 하는거야
예를들어 단백질 구조분석을 한다고 쳐보자
이게 뭔가 대단한게 있을거같지
별거없어
F = ma 계산을 갔다가 초당 수백만번을 하는거야
수백만번이 모야
몇조번을 하는거지
굉장히 간단한거에요
근데 그것때문에 굉장히 특별한 컴퓨터를 만들잖아
원래 이거 다 단백질 구조분석을 하려고 만든건데
잘돼서 그냥 팔고있는거야
뭔가 문제를 풀려그러다가 나온건데
(갑자기 폰노이만 아키텍처로 넘어감)

CPU
--------

어줍잖게 아는게
모르는거보다 더 안좋은거야
알라면 확실히 알아야돼
생각좀해
생각을 하고 정확한 답인가를 보고
니 생각을 논리적으로 argu를 해봐
stored program concept

폰노이만 아키텍처가 뭐가 특별해요? Stored Program Concept야. 문제를 하나 풀고
선을 다시 연결할 필요가 없어. 어디다가 저장을 했다가 다시 불러와서 쓰면 된다
이거지.

'프로그램 내장 방식' 참정확한 번역이 아냐. 참
안타까워요. 우리 나와있는 컴퓨터 90%는 다 쓰레기야. 자기딴에는 뭐 필드에서
지식이 싸였다고 쓰는데 전부 엉터리야.

30년대가 참 많은게 발견된 해야. 그 연도에 처치인코딩이
튜링머신과 1:1 대응되다는게 발견되었다
하버드는 데이터랑 코드 분리된것
람다칼큘러스 한번 배워봐
알만해
너무 수학적으로 가서 문제지
나도 배우고 한번도 안써봤어
실제로는 컴퓨터 구조에 대해 더 잘알고있는게 훨씬 필드에 도움이 돼

### Stored Program Concept

프로그램을 실행시킬때 선을 다시 연결하지 말고, 펀치카드같은데에 프로그램의
정보를 저장해놓으면 알아서 실행을 해주는것.

예전에도 말했지만 이 핸드폰에 들어가는 기술 진짜 아무것도 아냐. 이거는
머라그럴까 어떻게 이미 있는 기술을 어떻게 디자인과 잘 인터그레이션하느냐가 빛을
발한 케이스지. 중요한건 저전력화시키는 하드웨어, 어떻게 유저인터페이스 빠르게
하느냐. 우리나라 삼성엔 그런 기술이 없어.

삼성 부사장 한명 외에
최적화 잘아는사람 아무도 없어
성격이 굉장히 쓰레기같아요
나하고 굉장히 비슷한데
어떻게 그 대기업에서 인간관계를 유지하고 살까 했는데
원래 삼성 60살 넘으면 다 짤리거든
근데 아직도 8년 넘게 삼성에 계셔
IBM에서 컴파일러 하시던분인데
타이젠 만드시는거야

내 자식들이 잘살으려면 너희(대학생)들 전투력을 증가시켜야돼

### Processor, CPU, and Core

* Core
  * Instruction을 실행하는데에 직접적으로 관여하는 하드웨어들을 몽땅 묶어서
    코어라고 부른다.
  * ALU, FPU, Private L1/L2 caches, ...
* Processor or CPU
  * 한개 이상의 코어를 모아, shared resources를 붙여놓은것.
  * 문맥에 따라 Processor는 하나의 코어가 들어있는 칩을 일컫을때가 많다.

### Uncore

A term used by Intel.

코어 안에 들어있지 않은 하드웨어 컴포넌트들 (QPI controllers, L3 cache, ...)

### Techniques to Improve a Single Core

* VLSI 기술이 발전할수록, 칩의 공간이 늘어나서 이것저것 넣을수 있게 되었음.
* On-chip caches
* Instruction pipeline

### Dependences (dependency)

```
디펜던시 깐다
옳게 배운사람들은
Dependences 라는 용어를 써요
무식하게 배운사람들이 Dependency라고 불러요

이트 무라우 (??)라는 무슨 대학 ㅁㄴㅇㄹ 누구의 스승의 누구가 소프트웨어 병렬화의
필요성을 피력할때 처음 dependences라는
용어를 썼어요.

그래서 이걸 써야돼
유식한사람들은
너넨 나한테 배웠으니까 이 용어를 써야돼
그래서 책이랑 논문들을 보면
멀티코어 하는사람들 계보를 알수있어
그리고 Dependency 같은 단어가 들어있으면 리젝시키는거지
ㅎ~ 넝담
(비순차 실행 설명으로 넘어감)
```

순서가 뒤집혀서 실행되면 안되는 어셈 코드들

* Flow (true) dependence
  * 순서를 바꿀 수 없는 디펜던시
* Anti dependence
  *
* Output dependence
  *
* Input dependence

##### Dependence removal

```
t := a + b
c := t + 3
t := 4 + d
f := t + 5
```

이렇게 코드가 있는데, 이름만 약간 바꿔도 인풋 디펜던시/아웃풋 디펜던시가 다
끊어진다.

```
t1 := a  + b
c  := t1 + 3
t  := 4  + d
f  := t  + 5
```

### Pipeline Decode Execute
Stage 5개를 만들어요

IF -> ID -> EX -> MEM -> WB

이걸 한칸씩 밀어서 실행해요

```
IF -> ID -> EX -> MEM -> WB
      IF -> ID -> EX -> MEM -> WB
            IF -> ID -> EX -> MEM -> WB
```

### Pipeline Hazard
* 다음 인스트럭션이 다음 클락 사이클에 실행되지 못하는경우
* Data hazard
* Structural hazard
* Control hazard

### Data hazard

(PPT에 아주 좋은 그림이 있음)

### Resolving Data Hazards

* Stalling the pipeline
* 파이프라인에 거품을 끼워넣어서 일부러 몇사이클을 낭비해서 순서가 원래대로
  돌아올때까지 실행을 늦춤

##### Software

일부러 nop 을 끼워넣음

##### Hardware

* Transparent register file
  * Write-back을 두단계로 만들어서
* (그 외의 방법 PPT에)

##### Structural Hazards

* 두 코드에서 동시에 서로 다른 메모리에 액세스해야할경우

##### Control Hazards

분기명령으로 인해 이 뒤에 실행할 예정이었던 코드들이 다 무의미해질경우.

### Branch Prediction

의외로 잘통한다.

* For문 돌떄 쓰는 조건문. For문이 긴 for문이면 조건문 결과가 거의 항상 비슷하게
  난다.

소프트웨어 소프트웨어 하는데 하드웨어 없으면 소프트웨어 성능 절대 못뽑아요.

### Out of order execution (OoO)

IF -> ID -> Resevation station -> EX / EX / ... / EX -> Reorder buffer -> WB

### Tomasulo's Algorithm

IBM 360/91

* Single issue

* In-order issue
* Out-of-order executiokn
* Out-of-order dispatch
*

이재진교수님이
Out-of-order exec 만든사람한테
이것들 용어의 정의가 너무 모호해서
가르치는데 힘들다고
저거 만든사람한테
막 얘기했더니
그사람이
꼬마들 가르치는데 그거 명확할필요없다
이랬다고함

보통 전기 많이 쓰면 안되는 ARM7 ARM9같은 애들은 그냥 in-order-exec 함.

그리고
SNUVM 만든 이야기가 나온다
내가 이거 만드느라 ARM 레퍼런스를 수도없이 읽고
집에안가고 그래서 막 집에서 쫓겨나고 그랬어
이거 기억땜에 내가 이제 ARM은 편해요

### Issuing and Dispatching an Instrucion

### Precise Exception
익셉션도 순서를갔다가 우리가 보존을 해줘야된다는거야. 페이지폴트가 났다고쳐봐.
그러면 실행 도중에 인터럽트가 걸린건데, Page를 갔다가 OS에서 가져오든지 새로
할당하든지 할텐데, 우리가 out-of-order exec를 했기때문에 폴트가 원래보다 더 먼저
일어날 수 있어.

그래서 폴트가 나기 전엔 명령어를 전부 실행하고, 순서를 정확하게 보존해줘야돼.

### Retirement (Graduation)
Reorder buffer에서 instruction이 사라지는경우.

* Instruction이 커밋을 했거나 (폴트, ..) (the result is made permanent)
* Instruction이 없어졌거나 (without making permanent change)

### Superscalar Processors
Vector Processor는 아니지만, 여러개의 값(스칼라)를 동시에 처리해서 슈퍼스칼라
프로세서.

OoO 할때엔 issue를 하나밖에 안했었음. 하나씩 차례대로 이슈를 했었음. 하나의
이슈로는 안됨. 이슈를 여러개를 동시에 할 수 있으면 더 빠를거임.

Instruction Fetch랑 Decode unit을 여러개를 둠.

Dynamically issue multiple instructions in each clock cycle
* 이슈할때도 인오더로 이슈한거랑, 아웃오브오더로 이슈하는거랑 나뉘는데,
    out-of-order issue가 더 우수함

ILP(Instruction Level Parallelism), 한번에 몇개의 명령어가 동시에 처리될 수
있는가, 한번에 몇개의 명령어가 동시에 이슈될 수 있는가.

보통 동시에 실행시키는 명령어 갯수가 2.8개로 멈춰있어서 ILP가 일정 이상 발전을
안하고있음.

우리의 현실. 프로그램상의 디펜던스때문에 이슈를 동시에 할수가 없음. 하드웨어를
아무리 잘 만들어놔도 소프트웨어가 익스플로잇을 못하면 그게 안됨.

그런 문제를 어디서볼 수 있을까? 여기(갤럭시 스맛폰)에서 볼 수 있지.

### VLIW Processors

Very Long Instrucion Word

디펜던시가 없는 인스트럭션들을 하나의 긴 인스트럭션으로 만들어주는거임.
하드웨어가 다이나믹하게 스케줄링을 안해줘도 알아서 고정된 갯수의 여러
인스트럭션들이 동시에 fetch, decode, issue, execute됨.

프린터 안에 VLIW 프로세서가 많이있음. 아이태니엄에도 이런거 들어있음. 처절하게
망했죠?

Static instrucion scheduling by a compiler

삼성이랑 엘지에 컴퓨터 아키텍처 할 줄 아는사람이 몇명이나 있을것같나? 10년전까진
0명이었어. 디자인 오토메이션은 이거랑 전혀 상관없는데 자꾸 이걸 건들라그래. 근데
삼성이랑 엘지엔 디자인 오토메이션(캐드)만지는사람밖에 없어.

우리나라 삼성에 컴파일러 만지는사람이 몇명이나 있을것같아? 0. 러시아에 외주나
주고앉아있고. 상무가 쥐뿔도 모르는놈이 나 불러서 자기자랑이나 하고 3.5억 주고
외주한걸 잘했다고 자랑이나 하고있더라고. 인간같지도 않은놈이 안짤리고 잘
살아있고. 아직도 우리나라는 기술을 잘하는사람이 아니라 인간관계 좋은사람이 더
잘나가.

우근이가 할수있는걸 왜 삼성이 안할까? 자신감이 없어서그래. 잘못건드렸다가 돈
시간만 날리고 망할까봐 그러는거지.

컴파일러 아키텍처 이거 다 맞물려있는거야. 밑에 시스템 이해 못하면 소프트웨어
백날 만들어봤자 아무 쓸모 없어.

--------

> 3월 25일 (지각)

원래 프로세서 만들떄엔 타겟하는 어플리케이션이 무엇인지가 있어야해. 이런식으로
캐시 폴리시같은거 어떻게 정할지 모르겠을경우엔, 어플리케이션을 돌려보면
아는거야. 응용이 중요하다는거야. 삼성에서 프로세서를 만든다 하면 이걸 왜
만드는가 이런게 중요한거야.

### Non-Blocking/Lockup-Free Caches
이게 무슨소리냐. 둘이 같은소리인데

우리가 어떤 주소에 있는 데이터를 리퀘스트했는게 이걸 미스했어. 그러면 이걸
가져와야겠지? 근데 메모리까지 가져오기엔 너무 바쁘단말야. 메모리 레이턴시가
있잖아. 캐쉬에서 메인 메모리까지 가서 가져오는데 시간이 너무 기니까 하드웨어를
좀 더 둬서, 여러개의 미스를 동시에 처리할 수 있는/미스 패널티를 줄이는
하드웨어를 더 두자는거야.

MSHRs : Miss Status/Information Holding Registers

캐시가 미스되어 메인 메모리에서 정보를 가져오는중에도, 다른 캐쉬를 계속 줄수있는
캐쉬

### Cache Performance Metrics
캐시의 성능을 재는 세 기준

* Miss Rate
  * 미스가 얼마나 잘나느냐
* Hit Time
  * 캐시가 히트했을때, 얼마나 빨리 갔다주느냐
* Miss Penalty
  * 캐시가 미스되었을때, 얼마나 늦게 갔다주느냐

가상 메모리
--------
버추얼 메모리가 처음으로 생긴데가 어디냐. 이거 중요하냐 안중요하냐. 중요해. 야단
안맞으려면.

내가 Mutix 연구를 하다가 MIT에서 발표를하다가 이걸 MIT에서 처음 했다고 잘못
발표를 하다가, 뒤에 앉아계시던 노인이 너 그거 확실하냐고 하시는거야.  아틀라스
시스템 - 맨체스터 대학에서 처음 만든거다. 이러시면서 저녁먹고 좀 얘기좀 하재.
스티브 퍼버, 암 시스템 만든 70넘은 노인이야. 근데 내가 이거 틀려서 저녁먹으면서
한시간동안 계속 야단맞았어.

--------

> 3월 30일

지금 현재 머신러닝같은건 다 패키지화되있어요
서포트 베타머신
뉴럴네트웍
중요한건 속도야
그걸 누가하느냐
우리가 하는거야
말만 버즈홀
기초가 되는 기술이 쌓여있어야 할수있다고
근데 그걸 참 모르는거야
빅데이터 별거있어요 이름 그냥 가져다 붙인거야

미국에서 왓슨연구소 그런데는 맨날 속도만 신경쓰고있는데 우리는 분석하는법이나
배우고있어요. 아예 접근부터가 글러먹은거야. 이게 변하지못하면 우리는 남
따라갈수밖에 없어. 맨날 미국 뒤꽁무니나 쫓게되어있는거야.

새로운걸 해야돼. 새로운거 뭐 SnuCL 이런걸 해야지 (?) 게임회사 우리나라에 만개가
넘어. 거기에 또 들어가는놈들은 바보야. 새로워야돼

분산시스템은 코어 스크레인이죠. 근데 우리는 하나의 시스템 안에서 멀티코어를
쓰는거야. 하둡같은거 실제로 만든게 분산시스템을 위해서 만들었어요. 이게
스트리밍도 안돼고 그냥 Batch로 하도록 하둡을 만들어놨는데, 하둡을 어떻게 하면
슈퍼컴퓨터에서 빠르게 Real time processing 할 수있게 하느냐 이런거에요.

난 그런게 싫어
이론화한놈들이 이름 신기한거 다 붙여놨는데
BSB모델 RAM 모델
그거다 별것도 아닌건데 그거 이름붙여가지고 튜링어워드 받았다고
내가 진짜 우스워서
그사람 멀티코어에 발표한 논문 보면 쓰레기야 쓰레기
아무것도 모르는놈이말야
중요한건 옛날에 뭘 했느냐가 아니라
지금 뭘 하고있느냐야
내가 왜 이런소리를 하냐
시간이 좀 지나면 느낄수 있어요
나악우우우웅

가상 메모리
--------
가상 메모리 자체는 소프트웨어에서 하는거에요. 하드웨어가 아니라. OS가 해주죠.
가상메모리 구현도 하드웨어로 할수 있을지도 몰라. 구현을 하드웨어로 하는가
소프트웨어로 하는가는 장단점이 있지.

### Virtual Memory
운영체제에 의한, 메모리의 추상화

프로세스가 모에요. 실행되고있는 프로그램을 관리하기위해 운영체제가 프로세스라고
이름을 붙여준거야. PCD라고 해서 프로세스에 대한 정보가 한 자료구조 안에
들어있지.

주소 공간이라는 용어를 쓰는데, 프로세스가 가진 메모리의 범위를 주소공간이라고
그래요. 두 프로세스를 실행시킨다고 쳐봐. 주소공간이 같아요 틀려요? 달라요.
프로세스마다 다른 주소공간을 준단말야. 이게 Virtual Memory의 역할이야.

또 하나의 역할? 실제로 갖고있는 메모리보다 더 많은 메모리를 쓸 수 있게 함.

```
CPU -> 캐쉬 -> 버추얼 메모리 -> 캐쉬 -> 메인메모리 -> 보조저장소
```

어쨌든간에 우리가 소프트웨어로 이걸 한다그랬는데, 얘가 하는 역할이 무엇이냐.

### MMU and Pages
Memory management unit

가상메모리의 어디가 피지컬메모리의 어디에 해당하느냐, 이걸 운영체제가 해줘요. 북
키핑을 해줘야겠지? 이걸 페이지 테이블에 해요.

메모리가 32비트라고 치면, 앞의 12비트는 페이지 안에서의 offset이라고 치고 나머지
20비트를 page라고 봐도 된다고.

우리가 왜 캐쉬를 사용해요. 캐쉬를 사용하는 이유가 뭐야. 코스트를 줄이면서
빠른속도로 메모리를 액세스하기위해. 근데 주소가 올때마다 페이지테이블 룩어블
한다고 쳐봐. 이게 좋아요 나빠요? 나쁘지. 그리고 페이지 테이블 룩업할때 또 연산을
해야돼. 이 테이블이 어디에 해당하는지. 그럼 좋아 싫어? 싫지. 그래서 이걸
하드웨어로 계산하기위해 MMU라는걸 둬. 이게 거의 대부분의 CPU에 들어가있어.

### Page Tables
페이지테이블을 기록하는데에 뭐가 필요할까. 이게 실제 RAM에 올라가있는지, 이게
피지컬 메모리의 어느영역에 매핑되는지 이런 정보를 적어야겠지.

페이징, 디맨드 페이징, 스와핑

### Address Translation
버추얼 페이지의 세 타입

* Unallocated
* Cached
* Uncached

### Page Hit/Fault
버추얼메모리가 가서 MMU한테 갔어

커널이 뭐야
커널의 데피니션이 뭐야
오에스 들었다매
커널이 뭐야
잘한다
큰일이다 큰일
가장 기본적인걸 모르니까
모르는거야 어렴풋이 알겠는데 대답을 못하는거야
커널이 뭐야
커널이라는거는
OS에서 항상 메모리에 상주를 하면서 안쫓겨나가요
항상 OS에 상주해있는부분을 커널이라고 정의해
(스왑아웃 되지 않는부분)

### Page Replacement Policies
* LRU
* FIFO
* Second chance
* Clock
  * 이 페이지가 한번이라도 참조 되었나 안되었나를 저장함
    * 페이지가 처음 로딩되었을경우 `R=0`
    * 페이지가 레퍼런스 되었었을경우 `R=1`
  * 그리고 페이지들의 서큘러 리스트를 메모리에 저장함
    * 리스트를 순회하면서 `R=0`인애들을 스왑아웃해버림

### Translation Lookaside Buffer (TLB)
컴구 들은사람은 이거 알거야. 이것도 MMU 안에 들어있는건데

```
<@김젼> TLB 뭔지 모르겠당
<@김젼> 호에에에
<@sgm> TLB 모름?
<@sgm> 시프에서도 했는데
<@김젼> 지각해서
<@김젼> ._.
<@p> translation lookaside buffer
<@sgm> virtual memory address를 physical address로 바꿔야 되는데
<@p> 가상주소-물리주소 변환하는거
<@p> 캐시
<@김젼> 오홍
<@sgm> 이 정보가 메모리에 있어버리면
<@sgm> 저것도 메모리 보게 되니까
<@sgm> 오버헤드가 큼
<@김젼> 그래서 따로 캐쉬를 두는건가
<@sgm> 그래서 따로 캐시 둔 거
<@sgm> ㅇㅇ
<@김젼> 오홍
```

Small, virtually addressed cache where each line holds a block consisting of a
single PTE. 보통 Full associate cache로 만듬. 보통 메모리 실행할때 시퀀셜로
접근했던 메모리를 또 접근하니까 로컬리티가 높아서.

Micro-TLB

리눅스에서 하나의 페이지는 4kb에요.
페이지 크기가 크면좋겠어 작으면 좋겠어?
이게 장단점이 있어
페이지 크기가 작으면 테이블 룩업을 자주해야돼
TLB 미스가 자주뜨겠지?
페이지 크기가 크면 어때
2메가라고 쳐보자
2메가 페이지면 페이지폴트가 한번만 나면 좋은데
2kb면 페이지폴트가 512번 일어나야지
리눅스를 보면 휴즈 페이지라 그래서
페이지 크기를 크게 줄 수 있어
이러면 페이지 폴트 나는 퍼포먼스가 어떨까
꼴랑 2% ~ 3% 밖에 성능이 안좋아져
실제 실험 안해봤지 여러분?
이건 해봐야 아는거냐
큰 페이지가 좋은지 작은 페이지가 좋은지
시퀀셜하게 메모리 쭈욱 접근할때엔 큰 페이지가 좋겠지
근데 TLB랑 microTLB 성능이 워낙 좋으니까
성능이득이 별로 없는거야
근데 미디어쪽은 보통 메모리액세스가 시퀀셜해서
큰 페이지를 쓰기도 해요

리눅스같은경우에
버추얼메모리 끄는 옵션이 있어
MMU가 1:1 매핑을 하도록 바뀌어
보통 미사일이나 비행기에서 이런거를 써
왜 이런걸 쓰느냐
얘네들은 계산 시간이 들쭉날쭉하면 안돼
비행기나 미사일이 날아가는동안
미세조정을 하는데
이 계산을 하면 정확히 몇초후에 결과가 돌아와야한다
이 계산시간을 고려해서 조정을 한단말야

### Caches and Virtual Memory
캐시가 버추얼메모리를 쓸것이냐 피지컬 메모리를 쓸것이냐

Virtually addressed cache: faster, 하지만 보안 이슈가 있음. OS가 컨텍스트
스위치할때 캐쉬를 비워줘야됨. 컨텍스트가 무엇이냐. 이 프로세스가 돌다가 나중에
다시 돌기위해 Save해야하는 정보들 (PC, 레지스터, 스택, ...)

Physically addressed cache: 물리메모리를 캐싱함. Slower but no OS intervention

1.  Virtually indexed, virtually tagged
    * 캐시 미스가 났을때만 주소공간 변환이 일어남
    * TLB가 critial path에 있지 않음
1.  Virtually indexed, physically tagged
    * 보통 실제로 쓰임
    * 피지컬 인덱스 캐쉬보다 빠르고, 버추얼만으로 한건 프로세스간 구분이
      안되는데 이건 됨
    * TLB가 critial path에 있지 않음
    * ARM에선 보통 이걸 씀
1.  Physically indexed, virtually tagged
    * NEVER USED
    * No OS intervention for cache management
    * TLB is in the critical path
    * TLB 트랜슬레이션 한 다음에 캐쉬 액세스를 하기때문에 퍼포먼스가 느려짐.
      아무도 안쓰는 방법
1.  Physically indexed, physically tagged
    * TLB is in the critial path
    * No OS intervention for cache management

병렬성
--------
슈퍼컴퓨터를 ARM으로 만드는걸 내가 밀어놨는데. 펀딩이 될지 안될지 모르겠어.
대만같은 회사에선 요만한 공간에 프로세서 수십개 박아넣는 마이크로서버가 잘
되고있어. 우리나라에는 ARM쪽 생태계가 좀 잘 되어있는데 이게 펀딩이 아니면
우리나라는 운이 없는거야. 그나마 우리나라에서 잘되어있는게 ARM쪽인데
여기에서마저도 선전할 기회를 놓치면 우리나라가 운이 안좋은거야.

### Types of Parallelism
* ILP
* Task parallelism
* Data parallelism

### Task Parallelism
Banquet을 준비하는데, 네개 전채요리를 준비하는데, 서로 다른 종류의 job을 서로
네명이 나눠서 넷이 각각 준비하는거야.

요게 태스크 패러렐리즘

동시에 다른종류의 job을 실행하는것. 이게 제일 이상적인 패러렐리즘이야.
오버헤드가 아몰타이즈드 된거야. 그러나 실제로 찾아보면 이런것이 적용되는
어플리케이션이 별로 많지 않아.

### Data Parallelism
이건 가장 성공적이었고, 자동으로 할 수도 있는것

Loop-level parallelism이라고도 함. 루프를 도는데 각 이터레이션간에 디펜던스가
없으면 이걸 동시에 할 수도 있지

```c
for (i = 0; i < N; ++i) {
  c[i] = a[i] + b[i];
}
```

OpenMP같은건 디펜던스가 없으면 앞에 뭐 하나 붙이면 알아서 병렬화돼. pthread는
어때? 손으로 스레드를 만들어야하지.

예전에 C++이 C로 변환된다음 어셈블리가 나갔잖아? 그런거처럼 OpenMP도 pthread로
변환된다음 가던 시절이 있었어

### SIMD
A single program counter

CPU에서의 SIMD는 벡터 오퍼레이션이라고 하는데, GPU의 SIMD랑 좀 다름

### SPMD
Single Program Multiple Data

똑같은 프로그램을 여러 데이터에 다양하게 적용시키는것. 근데 이걸 하려면
프로그램을 켤때 내가 어느부분을 계산해야하는지를 계산해야하지? 이게 바로
패럴라이제이션 오버헤드

MIMD는 굉장히 고리타분한 용어이니 쓰지 않겠다. 이런 용어가 있다는것만 알아둬

SPMD라는 용어는 언제 썼을까? 60년대 말에 IBM에서 처음 썼어. 난 이걸 항상
레퍼런스하는데, 다른사람들은 이 용어는 알면서 이 논문도 레퍼런스 안하고 이
용어가 어디서 생겼는지도 몰라.

소프트웨어 파이프라이닝. HP에 있던 밥 라우라는 사람이 만든게 하나가 있고, 스태틱
싱글 어사인먼트 폼이라고 해서, 프로그램 트랜스포메이션이라고 하는게 있는데 이게
컴파일러계에서 아주 중요한 변화거든? 근데 사람들은 이 두 엄청나게 큰 변화가 누가
만든건지 몰라. 소프트웨어 파이프라이닝은 아는데 다 스탠포드 교수가 만든줄 알고,
프로그램 트랜스포메이션 논문을 보면 저자가 네명인데 정작 중요한사람은 빠져있어.
그래서 이사람들 다 뭐하느냐? (누군가 치킨집이라고 말함) (수업 마비) 실제로
치킨집 차린건 아니고 비슷한건데, 농사짓고있어.

--------

멀티스레디드 아키텍처, 캐시 코히어런스, GPU 아키텍처
--------

Control flow = 실행 순서를 바꾼다. 브랜치 넘버

인스트럭션 사이클 = Fetch Decode Execution Writeback

OS가 하나다, 와 OS 인스턴스가 하나다라는 뜻은 달라

```
<@김젼> 그건 페치 디코드 익스큐션 인스턴스가 여러개다,
<@김젼> 프로그램 카운터가 여러개다
<@김젼> 멀티코어 수업에서
<@김젼> 처음으로 멀티코어를 만져서 그런지
<@김젼> 이렇게 한 슬라이드 오래하는거 처음이다
<@김젼> 수퍼스칼라 프로세서가 뭐하는거에요
<@p> 히익
<@김젼> 여러개의 펑셔널 유닛을 둬서 ILP를 둬서 수행을 여러개를 하는거지
<@unused> HINSTANCE hInstance;
<@김젼> 근데 ILP를 하더라도 인스트럭션이 하나의 스레드에서만 오기때문에
<@김젼> 하나의 스레드면 평균 ILP가 3이라고 했지
<@unused> typedef HINSTANCE HMODULE;
<@김젼> 펑션 유닛이 4개 5개 있어도 다 논단말야
<@p> 노잼..
<@김젼> 노니까 여러개의 스레드를 동시에 돌리면서 여러개의 스레드에서
인스트럭션을 가져오자는거야
<@김젼> 이게 기본이야
<@김젼> 멀티스레디드 맨 처음 제시한사람이
<@김젼> 조얄 해머 (??) 이름 뭐지
<@김젼> 유니버설 오브 워싱턴 박사과정이랑 쓴건데
<@김젼> 크레딧은 지도교수가 받았는데
<@김젼> 지도교수는 아무것도 한게없어
<@김젼> 사람들은 다 수잔 누구(지도교수)가 한줄 알아
<@김젼> 조얄 해머(??)는 인더스트리에 있던사람이야
<@김젼> 딘 트루센이라는 친구에요 이친구가 나랑 커리어를 같이 시적하고 샌델(?)
교수인데
<@김젼> 그사람이 이거 논문을 사이멀테이너스 멀티스레드라고 발표하고
<@김젼> IBM 파워피씨에 처음 적용하고
<@김젼> 인텔에서 이걸 가짜로 베껴서 하이퍼스레딩이라고 발표하고
<@김젼> 파워피씨에 비해 아주 안좋았는데 이제 좋아졌지
```

### Thread-level Parallelism
여러 실행 스레드를 사용해, 명시적으로 병렬 실행을 함.

### Issue Width of Superscalar Processors
동시에 이슈할 수 있는 갯수

### Superscalar Processors
하드웨어적으로는 아무것도 할게없고 소프트웨어적으로 컨텍스트 스위칭하면서
도는거. 모든 명령어가 항상 동시에 최대로 병렬화되어 이슈될 수 없지.

* Vertical waste (completely empty)
* Horizontal waste (partially filled)

### Vertical Multithreading
Vertical 하게 빈 공간에 다른 스레드를 넣자. 근데 아직도 Horizontal waste는 있음

* 스케줄링
  * fine-grained multithreading: 사이클 단위로 컨텍스트 스위칭
  * Coarse-grained multithreading: 컨텍스트 스위치하거나 캐시미스나거나 해서
      시간낭비되는동안 다른거 실행하기

### Simultaneous Multithreading (SMT)
인텔에서 하이퍼스레딩이라고 부르는것.

스레드가 하이퍼스레딩하는건 OS는 못봐요. OS는 로지컬스레드만 보는거고, 피지컬
스레드는 못봐. 만약에 코어 하나가 하이퍼스레드를 4개 한다 치면, OS는 코어가 4개
있는걸로밖에 안보여.

하이퍼스레딩의 단점.

* 데이터레벨 페러렐리즘을 할경우, 비슷한 명령어를 계속 실행할텐데, 이미 포화된
  ILP가 더 포화될 수 없어서 별 도움이 안됨. 그래서 실제로 인텔 하이퍼스레딩이
  성능이 별로 안좋음
* 캐쉬 로컬리티가 떨어져서 안좋음

```
특허
존나 쓸떼없어
우리나라 연구소에서 누구네보다 특허 많이냈다
백날 특허냈다고 해도 아무 쓰잘떼기없어
내가 정부에서 9년짜리 프로젝트를 하는데
3년마다 맨날 듣는소리가 왜 특허가 없냐고 그래
그럼 난 가서
국민들 세금이 아까워서 특허 못내겠습니다 그래
난 오픈소스로 푸는게 훨씬 가치있는거라고 생각한다그랬어
그래서 나중에 심사위원이 부르더니
그거 대드는거라고 그랬어
내가보기엔 특허라는건 없어져야해
나도 어쩔수없이 특허를 내놓고 이용을 하지만
요즘 특허내는거 보면 다 말도안되는거밖에 없어
어떻게 아이콘 가장자리 동그란거에 특허가 걸려있어
그레이엄 벨
저녁먹고 특허청가느라 2시간 늦어서 특허를 못얻었어
특허 낸다고 중국에서 짝퉁 못만드는줄아나
신문에서 특허 많이 낸다고 자랑하는데 그거 하나도 국익에 도움이 안돼
MIT는 바보냐 특허 하나도 안내는데
그거 변리사 좋은일 시켜준다고 안하는거야 돈아까워서
```

내가 왜 자꾸 용어를갔다가 중요하게 여기냐면, 여러분들한테 아키텍처 레퍼런스
메뉴얼 읽으라고 시키면 읽기 힘들어. 그것도 못읽으면서 컴공 졸업하면 웃기는거지.
뭐했냐 이거야.

### Homogeneous Multicores
캐쉬, 펑셔널 유닛, 프로세서 스테이트

* 셰어드 캐쉬
* Multiple processor state (하이퍼스레딩)

인텔같은애들은 자기네 시뮬레이터가 있어. 그건 오픈을 안해요. 자기네 프로세서
디자인할떄 쓰는거라

Cache Coherence Problem
--------
캐쉬 일관성이라고 흔히 번역되지만, 메모리 일관성(메모리 컨시스턴시)랑 용어가
겹쳐. 근데 저 둘은 전혀 다른 문제임

* 우린 캐쉬가 항상 최신값을 리턴하기를 기대함
* 근데 멀티코어에선 한 캐쉬에 뭘 쓰면 반대쪽 캐쉬엔 그게 반영이 안됨

유니프로세서서 시절에도 이 문제는 있었음. 다이렉트 메모리 액세스는 뭐에요. RAM을
안거지고 바로 I/O로 가는거지.

해결책

* 작업 하기 전, 후 매번 캐쉬를 비움
* DMA가 일어나는 영역 자체를 uncacheable로 만듬

캐쉬 코히어런스 문제 해결책

* Invalidate based protocol: 공유되는 캐쉬 값을 쓸때, 캐쉬 라인에서 아예 그
    캐쉬를 지워버림. 그럼 다른 캐쉬에서 그 값에 접근하게될때엔 캐시미스가 남
* Update based protocol: 공유되는 캐쉬 값을 쓸때, 다른 코어들에게 업데이트된
    캐쉬 값을 업데이트시켜줌.

각자 장단점이 있음.

소프트웨어로 할수도 있고 하드웨어로 할수도 있음

* 소프트웨어기반
  * 컴파일러/런타임
  * 하드웨어 지원
  * 근데 하드웨어에 대한 완벽한 정보가 필요함 (얼라이어싱, 페러렐리즘, 등..)

이걸 굳이 스태틱하게 하려는 놈들이 있는데 난 왜 그렇게 하려는지 이해가 안가.

하드웨어로 해도 북키핑 하려고 할라그러면 이것도 코스트가 많이 들어가. 그러니까
그냥 아무것도 하지말고, 소프트웨어에 맡기고 런타임에 해결하자.

#### 여러분은 세계에서 다섯손가락 안에 들어가는 메모리 컨시스턴시의 권위자의 강연을 듣고있습니다
왜웃어 임마
너 죽을라고
캐쉬 코히어런스는 내가 권위자가 아냐

Modify, share, invalidate. MSI, MESI(인텔), MOESI(암드) 등 여러 캐쉬 코히어런스
프로토콜이 있다. 여러분은 신경 안써도 돼요 하드웨어가 알아서 다 해줘

* Coherence misses
  * Invalidate할때 메모리에서 가져오는거

* Shared cache를 쓰면 이 문제가 사라짐

### Snooping

캐쉬 컨트롤러들이 캐쉬라인을 훔쳐보고(Snoop), 인밸리데이트하거나 바뀐 값을 다른
캐쉬들에 업데이트시켜주는 일련의 과정을 스누핑이라고 부름

### Coherence and Write-through Caches
Write-through 캐쉬에도 다른 코히어런스 문제가 있음

```
동시에 쓴다
동시에 쓴다 하는데
동시가 뭔지 알어요?
네슬 램버트
시퀀셜 컨시스턴시
얘네 논문쓸때
레퍼런스에
클락의 동시성 논문에
특수상대성 논문 들어있어
```

### False Sharing
한 캐쉬에서 RAM에 write-through할때, 그 메모리를 잡고있는 캐쉬를 전부
invalidate해야됨. 그래서 이건 진정한 sharing이 아님. 이거떔에 퍼포먼스
데그리데이션이 많음.

Update based protocol에선 이런일이 없음. 근데 Invalidate based protocol에서는
일어나지.

C volatile은 실제 메모리장벽을 전혀 안쌓아줌. 내 박사논문이 이거야

--------

> 4월 6일

GPU 아키텍처
--------
GPU 아키텍처들은 밑에단 공개가 잘 안되어있어. 이유가 뭘까? 이유가 자주 바뀌기
떄문이 맞아. 근데 왜 이걸 공개를 안할까? 밑에 레벨을 공개를 해놓으면 그걸
이용해서 소프트웨어를 만들어버려. 그럼 다음 아키텍처로 넘어가면 그게 돌아가?
안돌아가. 그래서 굉장히 하이레벨로 개발하도록 강제를 하는거야.

그래서 이쪽 알아내는게 굉장히 힘들어요. 캐쉬 어떻게되어있고 이런거 다 역공학으로
알아내야돼. 그래서 세계 그 어느 누구보다도 우리 학생들이 더 잘 알고있어. 이게
경험과 피나는 노력을 통해서 아는거야. 그런걸 아는게 왜 중요할거같애. 시스템을
알아야 좋은 소프트웨어를 만들 수 있어서 그래.

지금 삼성에서도 모바일용 GPU 만들고있죠. 근데 디자인을 미국 연구소에서
주도하고있으니까 답답한거야. 우리 학생들한테 맡기면 6개월정도면 만들텐데.

너네도 다 똑같애. 다 할 수 있어. 자기의 능력을 의심하지마. 다 우리가 똑같이 할
수 있는거에요.

### Rendering
렌더링이 뭐에요? "Process of generating an image from a 3D model"

2차원에서, 모든 폴리곤은 전부 삼각형으로 나눌수 있죠. 이렇게 삼각형으로 잘게
쪼개 모델링해서 처리를 하는거야. 고게 3D 모델링이고 고걸로 이미지를 만드는게
렌더링

### Rendering pipeline
1.  Vertex processing
1.  Geometry processing
1.  Rasterization
1.  Pixel processing
1.  Output merging

하드웨어로 만들어버리면 속도는 빠른데 뭐가 안좋아? 범용성이 떨어지지

### Shaders
GPU를 그래픽스만 처리할 수 있는 기계로 만들지말고, 범용 기계장치로 만들자. 그
GPU에 올리는 프로그램을 셰이더라고 부르고, 이게 돌아가는 코어를 셰이더 코어라고
부른다.

### General purpose CPU
보통 CPU는 실제 엑스큐션에 필요한 레지스터보다 그 외의 레지스터가 훨~ 씬 많음.
성능 높이려고.

### Shader cores
* Very simple programmable
* No architecture components that make a single instruction stream run fast
* Logical graphics pipeline
  * Vertex shader, Geometry shader, Fragment shader, etc

### GPU 아키텍처
아키텍처를 디자인할때엔 뭐가 중요하다고? 실제 어플리케이션을 봐야돼. 어떻게
쓰일지. GPU는 코어간의 디펜던스가 없어. 그리고 삼각형이랑 픽셀이 수백만개야.

"Massivly parallel processing"

```
<@sg126> 파이프라이닝도 하고 스케쥴링도 함
<@sg126> 근데 파이프라이닝도 하고 스케쥴링도 하는거 맞음
<@김젼> 그렇군
<@sg126> 내가 스냅드래곤 개발자한테 직접 들음
<@김젼> 어떤 스케쥴링을 하지?
<@sg126> 그림을 쪼개서 타일을 만들고
<@sg126> 타일별로 어떤 타일을 어느 타이밍에 어떤 명령어를 컨슘할지
<@sg126> 내부적으로 스케쥴링함
<@sg126> 그래서 메모리 타이트한 상황에서 잘못쓰면 메모리할당을 못해서 그림을 못 그리는데
<@sg126> 그게 타일별로 나타남
<@김젼> 그러쿤
<@sg126> 타일 크기는 드라이버제작자가 설정해서 줬는데 어쨌든 파워오브2로 줬던거 같고
```

### Exploting Massive Parallelism
각 픽셀마다 같은 오퍼레이션만 적용한다.

SIMT: Single Instruction Multiple Thread

* Single Fetch/Decode logic
* Multiple ALU & Context
* shared context data

인스트럭션 하나를 카피해서 여럿한테 돌림.

### Executing Branches
한 브랜치 실행하는동안 다른 브랜치는 그냥 멈춰버림.

* Conditional execution in a warp
* Hardware automatically handles divergence

### Hardware Context Switch
* To avoid stalls caused by high latency operations
* A single SM can run more than one warp

L1 캐쉬 액세스하는데 서너사이클 걸림. 근데 메모리 액세스하는데엔 30사이클
넘게걸림. 이런걸 High latency operation 이라고 부르면 됨.

### Multiple Streaming Multiprocessors

### 전반적인 구조
스칼라 프로세서, 로드 스토어 유닛이 아주 많다. 이것들 네개당 SFU(스페셜 펑셔널
유닛)이 드문드문있고, 얘네들이 모두 하나의 L1 캐쉬, 셰어드 메모리를 공유하고 그
밖에 L2 캐쉬 있고 글로벌 메모리가 있음.

### GPU Summary
* Data parallelism
* Hardware context switch to tolerate high latencies

메모리 컨시스턴시
--------
캐시 코히어런스와의 차이점.

컴파일러는 inter-thread 디펜던시를 따지지 않음. 이게 문제임. 컴파일러와
아키텍처가 OoE 하면서 리오더링을 할 수 있고, 이게 네트워크로 연결된 롱 레이턴시
멀티프로세스 시스템에서 실행되면 메모리 레이턴스때문에 메모리에 도달하는 순서가
바뀔 수 있음. 여러가지 이유때문에 리오더링이 발생할 수 있음.

어떻게 리오더링이 안되게 해야할까? 리오더링이 발생하면 안되는 지점을 명시적으로
지정해햐아한다.

캐쉬 코히어런스는 하나의 메모리 로케이션을 액세스하는 문제임. 근데 메모리
컨시스턴시는 메모리를 액세스하는 순서의 문제임.

### Memory consistency models
상대적으로 메모리 액세스가 일어나는 순서 자체가 어떤 순서로 일어나야 되느냐 에
대한 제약사항을 말함.

일단 셰어드 메모리, 싱글 프로세서를 가정하고 배우자.

한 업데이트에 대한 메모리가 언제 다른 프로세서에게 보일까?

1.  프로그래머에게 있어서 프로그래밍을 얼마나 공격적으로 할 수 있는가의 기준이 됨.
1.  얼마나 많은 액세스가 리오더 될 수 있느냐를 결정할 수 있는 기준이 된다.

대표적으로 네가지 메모리 컨시스턴시 모델이 있고, 이걸 쪼금씩 쪼끔씩 고쳐서
쓰는거임.

* Sequential consistency (Correctness criteria)
* Relaxed memory consistency models
  * Processor consistenty
  * Weak ordering
  * Release consistency
  * ...

복잡할수록 틀린거임.

### Sequential Consistency
멀티스레디드 프로그램 P의 실행결과는, P를 일렬로 늘여세워서 만든 싱글스레드
프로그램의 실행결과와 같아야함.

A total order between operations is defined (atomic operations).

컨시스턴시에 있어 제일 강력한 컨스트레인트.

### Program Order
Order in which operations appear in source code

* 어셈블리 코드로의, 소스코드의 자명한 변환
* At most one memory operation per instruction

하지만 컴파일러에 최적화될 수 있기때문에, 실제로 실행되는 순서와는 다름.

### Reasoning Based on SC

### SC Violation
내가 업데이트한것이 업데이트가 느리게되어서 생기는 문제.

### Relaxed Memory Consistency Models
인스트럭션 사이에 Fence Instruction을 집어넣음. 그 펜스 인스트럭션 범위를
넘어서는 리오더링이 못일어나게함.

### Performed with respect to ...

### Processor Consistency (PC)
Write buffer가 뭐게. write를 시퀀셜하게 죽 하는데 하나씩 메모리에 가면 시간이
무지 오래걸리지? 그렇게 하지 말고 write buffer에 모았다가 한번에 보내면 메모리
트랜잭션 하나로 여러 write를 할 수 있지. 근데 이 write buffer를 하려면 프로세스
컨시스턴시가 필요해.

write 버퍼를 하드웨어에 넣으려다보니 만들어진거임.

근데 이거 거의 안쓰여.

Read is allowd to perform with respect to any other processor, all previous read
must be performed

이게 무슨뜻이냐면

> read -> read (다른 메모리 로케이션 접근할때)

가 지켜져야한다는 뜻임.

Before a write is allowed to perform with respect to any other processor all
prvious accesses must be performed

> read -> write
> write -> write
> ~~write -> read~~ (relaxed)

라는 뜻임

86~88년에 쓰임.

##### Relaxing write -> read order
Processor consistent 하지만 not sequentiall consistent 할 수 있는 상황이 있음.

### Weak Ordering
Relax all program order. 하지만 Synchronization operation들 사이의 시퀀셜
컨시스턴시는 지켜줘야하고, 싱크로나이제이션 오퍼레이션 전후로는 모든 메모리
I/O가 끝나야함.

이러한 특징때문에, 프로세서 하나에선 싱크 오퍼레이션은 항상 하나에만 일어남.

IBM PowerPC가 위크 오더링을 따름.

### Release Consistency
Releax all program orders, but not w.r.t. sync operations

Two separate synchronization operations

* Acquire: A read operation such as lock
* Release: A write operation such as unlock

Acquire가 나오고 뒤에 read, write가 나오면 어콰이어 앞으로 못감.

Release가 나오고 앞에 read, write가 나오면 릴리즈 뒤로 못감.

Acquire, release 싱크 오퍼레이션들끼리는 모두 시퀀셜리 컨시스턴스 (혹은 프로세서
컨시스턴트) 근데 프로세서 컨시스턴시보다 시퀀셜 컨시스턴시가 더 나옴.

91년도에 나온거임. x86에서 쓰는거임.

메모리 컨시스턴시 모델이 왜나왔어. 리오더링을 하면 우리가 원하는 결과가
안나오기때문에 그런거지.
