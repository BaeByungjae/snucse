Programming Language
========

> 9월 1일

(지각)

이제 프로그래밍 패러다임에 따라 나누는 시대는 끝날거에요

Rust를 아니? (김지현 감탄)

이친구는 신도에요 신도.

이건 별로 바람직하지 않죠. 여러분들은 아직 어리니까 빠져가지고 흥분하고 그런거
좋아. 쫙 빠져들었다가 그다음에 다시 나올 수 있는 면이 있어야해. 아무리 좋아도
에이 그지같은면이 있거든. 다시 빠져나올 수 있지 못하면 여러분들은 의미가 없어.
여러분들은 좀더 좋은것을 위해서 리딩해야돼요. 믿고 따르라는게 아니라, 좀더
좋은것을 위해서 앞장서라는 의미야.

그래서 다양한 랭귀지가 만들어지고있고, 여러가지가 펼쳐지고있습니다. 아 이
많은것들중에 어떤것을 선택해야하고, 더 좋은걸 위해 만들려고 노력하는것이
필요해요.

여러분들 학부생으로써는 이 강의를 듣는다고 그런 능력이 갑자기 확 생기는것이
아니지만, 눈높이 시각 삐딱하게보기 그런ㄱㅅ이 가능해져야돼.

그래요. 목표가 대충 제가 추상적으로 말씀드렸지만 그렇습니다.

그리고 내용을 말씀드리면요, 제 강의는 파트 0, 1, 2로 나눠져있어요.

0은 기초. PL 하는사람들이 언어를 정의하고 설명하고 그럴떄 쓰는 어휘 개념 방법이
있어요. 그런것에 대해

그리고 파트 1, 2가 이 강의의 ㅏㄹ점, 고깃덩어리입니다. 프로그래밍 언어라는것이
정확하게 두개의 기원이 있습니다. 하나는 튜어링 머신이라는 기원이 있어요.
튜어링은 들어보셨죠. 튜어링 기계라는것이 하나의 프로그래밍 언어의 기원이구요.
왜그런지 곧 말씀드립니다. 또 하나는 람다 캘큘러스 라는게 있습니다. 람다 계산법.
람다는 알파 베타 감마 람다 그 람다에요. 시옷모양.

튜링머신은 기계입니다. 이건 물건. (상자 그림)

람다 __칼큘러스__는 계산입니다. 이건 값이에요. (10010101...)

프로그램 실행을 함에 따라서 장바구니 안에 들어있는 상태가 변하고, 프로그램
실행이 다 끝나면 장바구니 안에 들어있는것이 결과야. 구우웃. 베리 내츄럴해.
이렇게 시간이 지남에 따라 상태가 변하는 느낌의 프로그래밍 기원이 튜링
머신이에요.

또 다른 기원은 람다 칼큘러스에요. 튜링머신과 람다칼큘러스는 거의 같은해에
고안됩니다. 이것도 프로그래밍 언어의 기원이에요. 값이야. 1 더하기 3을 해.
1에다가 더하기 3을 해요. 장바구니에다가 더하기 3을 해요, 그럼 장바구니가 변해
그게 아냐. 1 더하기 3을 해요 그러면 장바구니가 변하는게 아니라, 그냥 4가
되는거야. 변하지 않어. 이것도 자연스러운 프로그래밍 스타일일 수 있어요.

근데 다행스럽게도 프로그래밍 랭귀지의 세계에서, 튜링머신쪽으로 막 발전했던
과정과 람다칼큘러스 한쪽으로만 막 발전했던 과정 둘중 하나만 있었다면 굉장히
고통스러웠을지 몰라. 근데 다행히 둘을 축으로 동시에 발전해서 아주 좋아졌습니다.

이 두개를 굳이 파라다임이라고 해야할까? 파라다임이라고 부르고싶으면 부를 수
있어요. 하지만 이걸 굳이 둘이 구분하지 않겠어요. 90년대까진 두 파라다임이 완전히
쪼개져서 서로를 막 욕하고 싸웠어요. 싸웠다기보단 서로 argue하고. 근데 별로 의미
없습니다. 두개가 합쳐져서 이렇게 생각하는 프로그래미 필요할때엔 이렇게 짤 수
있고 이렇게 생각하는 프로그램이 필요할때엔 이렇게 짜고.

제가 파트 1에서 말씀드리는 이야기가 주로 이거(튜링머신)이에요. 파트 2가
이거(람다칼큘러스) 이겁니다.

여러분 아마 폰 노이만 머신도 들어봤을거야 그죠? 못들어보신분들도 괜찮아.
튜링머신이랑 비슷한 어떠한 기계야. 이게, 튜링머신이라는거는 이사람이 직접
물건으로 기계를 만들진 않았어요. 종이에 이 컨셉만 만들고 말았어요. 이거를 진짜
여러분들이 혹시 디지털 논리 들어보셨어요? 혹시 저희 컴퓨터공학부에서 개설하는
논리설계 강의 들으신분? 거기에서 뭘 배워요? 뭘 배웠어? (0과 1로 상태를 잘
표현하는걸 배웠어요) 그랬어요? 또. 그거말고 또? 왜 이름이 논리설계야? 이 앞에
디지털이라고 붙지 않아요? (안붙어요) 0과 1로 뭐하는거배워? (상태를) 상태를
표현하는것. 또 뭐배워요 여기서? 괜찮어 말해. 생각나는거 다 얘기해 내가
여러분들한테 정답을 기대하고서 점수매길라는거 아냐. (뭔가 설계하는거) 쪼금
심한데. 그 뭔가는 뭘까? (논리회로) 논리회로 그게 뭐에요? 논리회로 그게
어따쓰는거야? (컴퓨터) 그래요. 컴퓨터를 진짜로 구현할떄. 튜링머신에서 만든
컨셉을 실제로 구현할떄 쓰는거야.

다른방식으로 만들수도 있어요. AND OR NOT으로 만들지 말고, 다른방식으로도 만들 수
있어 하지만 여러분들이 갖고있는 컴퓨터는 다 이렇게 만든거야.

만들고나서 프로그래밍 언어가 디자인됩니다. 그러면 자연스럽게 어떻게
디자인되냐면, 튜링머신에 적합하게 디자인되어요. 메모리가 있고, 메모리에다가 뭘
쓰고 하는 랭귀지가 고스란히 고안이 되어요. 자연스럽게. 이걸(람다) 쳐다도 안보고.
그래서 컴퓨터가 하는 일이라는게 메모리에다가 상태가 막 변합니다. 상태가 변하면서
일을 해요. 그러면 랭귀지도 상태가 변하는것을 표현하게끔 디자인이 되어요.
그렇겠죠? 그런 랭귀지들에 대한 이야기에요. 자연스러운데, 뒤돌아서 40년 후 50년
후에 보면요 맨 처음에 만들어지고, "야 불편해 죽겠다 이거 프로그래밍 어떻게하냐"
하면서 좀더 상위의, 상위의 레벨로 올라갑니다. 하면서 그당시 발전된 언어들 보면
굉장히 상식적으로 만들어져요. 상식은 좋은겁니다만, 프로그래밍 언어에 대한 공부,
디자인에 대한 고려 없이 상식으로만 만들어요. 기냥 요렇게 하면 되지 뭐 하면서
뚝딱뚝딱 만드는거에요. 대부분의 모든 랭귀지들이 이 피쳐(튜링머신)를 기반으로
발전해요. 그리고 이 언어가 마구잡이로 만들어졌는데, 굉장히 널리 쓰이다보니
문제들이 정말 많아요. 그래서 사람들이 반성을 하기 시작합니다.

여러분 언어 처음으로 뭐배웠어요? (나: C언어요) 언제배웠어? 6살때? (고1떄요) 우와
우리는 엄청나게 위험한 면도칼을 열다섯살(나)한테 줬구나.

우리는 C언어를 만든 사람들이 밟아왔던 스텝을 그대로 걸어갈겁니다. 어셈블리로
한번 만들어보고 어 조금 불편하네 새 언어 만들자, A B C. 그때 언어들 이름이
실제로 이렇게 붙었어요.

그리고나서 람다. 람다칼큘러스를 기반으로 삐딱하게 보기를 시작할거에요.
프로그래밍 랭귀지에서 계속 남아있는 중요한 컨셉트가 이동네에서 고안된게 몇개
있어요.

그다음에 파트 2에선 뭐할거냐면, 우리가 배운 이론들을 배경으로 최대한 좋은 언어를
잘 디자인하는 과정을 가지려고합니다.

그렇게 파트1, 파트 2하면서 제 강의가 마쳐지게될겁니다. 강의가 고렇게 구성됩니다.

수업 구성은 이상과 같습니다.

강의 자료는 제가 쓴 강의노트에요. TA가 웹보드를 통해, 제본신청을 받아서 제본을
해줄거야. 홈페이지에서 PDF 받아서 뽑아도 됩니다.

숙제는 여러분들에게 OCaml이라는 언어로 하도록 강요합니다. 상대적으로 학생들
사이의 숙련도 차이 없이 같은 레벨에서 할 수 있도록 할거에요.

최재승: 310ta@ropas.snu.ac.kr, x1865

여러분 조교는 괴롭히는사람이 아니에요. 여러분들을 도와주는 사람이에요.
온라인으로 과목 웹보드나 조교페이지로 많은것들을 공지할겁니다.

퀴즈는 없어요.

그리고 이 수업은 시험이 없어요. (크으으으으응) 내기억에 시험이라는건 의미가
없어요. 보고나면 다 까먹어.

프로그래밍 숙제는 컴퓨터를 통해 제출합니다. 정해진 시간까지 Submit하고, 편하게
다 되어있으니까 걱정하지 마세요. 근데 항상 보면 바쁘자나 그지? 바뻐요 그래서
듀를 놓칠수도 있어요. 저한테 와서 교수님 듀를 늘려주세요, 안됩니다. 듀는
못늘려줘요. 단 여러분들이 48시간 내에 늦어도 내도 되요. 패널티 10프로 감점을
감수하시면 됩니다.

에세이는 제가 여러분들에게 읽을거리를 줍니다. 그리고 읽고 읽고나서 내 머리의
상태가 어떻게 변했는지, 글을 쓰면 됩니다.

챌린지는 안해도 돼요. 근데 여러분들도 할 수 있는 문제에요. 여러분들이 보고서
할만하다 싶으면 하십시오. 작년에 60~70명 들었는데, 그중에 챌린지를 한 사람들이
25명이야. 해봤지만 다 틀린사람이 그중에 2명 있고. 두단계 올라간 사람도 있고,
세단계 올라간 사람도 있어요. 이친구는 B+였다가 A+가 되었어. C+받은사람이
B0된사람도 있어. A+받은사람이 A+된사람도 있고 그래.

그다음에 중요한게 하나 있습니다. 숙제 복제하면 안돼요. 숙제점수 모두가 0점이
됩니다. 항상 이걸 받는사람이 있어요.

숙제 듀는 이미 다 정해져있습니다. 다른 과목이랑 로드밸런싱할때 도움이 되도록
참고하세요.

--------

프로그래밍 언어가 무엇인가? 할때, 이 그림을 그리(코끼리 뒷모습)는 슬라이드가
있습니다. 눈을 감고 코끼리의 이곳 저곳을 만지는거야.

프로그래밍 언어가 무엇인가? 라고 물으면 굉장히 많은 답변을 할 수 있습니다.
기계를 추상화하는 언어, 알고리즘의 노테이션, DSL, 등등.

그리고 또 그림이 있어요.

```
DB         시큐리티 프로토콜 디자인     소프트웨어 베리키페이션  게임 프로그래밍
  로봇프로그래밍     베리피케이션    칩 디자인       랭귀지 프로세서
--------------------------------- Languages ------------------------------------
```

다 랭귀지야. 단순히 랭귀지를 써서 만든다는의미 이상으로, 랭귀지의 기술들이
여기저기 들어갑니다.

SQL. 로봇이면 굉장히 안전하게 돌아가야겠지? 시큐어 프로토콜. 내가 박근혜
대통령인척 하는거 못하도록. 칩 디자인. 베릴로그. VHDL, 베리 하드 디스크립션
랭귀지. 블루스펙. 블루스펙 디자인하신분이 여기에 2~3년 계셨었어요. 그 교수님이
랭귀지쪽에 이론으로 유명하셨던 분입니다.

PL.

우리 PL은 Foot note of Math. 많은경우 수학과 Logician에 이미 고안된 개념을
가져다 씁니다.

##### 요약
```
처음으로 배운 프로그래밍 언어 뭐에요?
C 요
여섯살때 배웠어?
고1때요
여기서 생각하죠 아 우리가 열다섯살짜리 아이에게 굉장히 위험한 면도칼을 줬구나
```
```
로봇 프로그래밍 중요하죠
삐용삐용
쿠왕
쾅쾅
투쉬 투쉬
(필기)
```
```
시큐어 프로토콜
제가 박근혜대통령인척하지 못하게 합니다
```
```
VHDL
베리 하드의 약자죠.
```

CSE가 뭡니까? (장호: Science of abstraction) 그건 내생각에 Math야.
(Engineering of abstraction?) 90점. 내생각에 이건 뭐냐면 Mechanization of
abstraction이야. 수학적으로 추상적인 개념들을 자동으로 작동시킬 수 있도록
하는거야.

> 9월 3일 결석

> 9월 8일 지각

```
@김젼	Inductive Definition
@김젼	귀납적 정의
@김젼	언어 정의할떄 이런 노테이션을 써요
@김젼	귀납법에 익숙해져야해요
@김젼	그냥 대놓고자네
@김젼	몇몇은
@김젼	어떤집합의 모든 원소들이
@김젼	어떤어떤 성질을 만족하다
@김젼	이런 명제를 증명할떄
@김젼	귀납법을 씁니다
@김젼	마교수님 기호 신기하다
@김젼	뭐야익
@p	|-
@김젼	슬래쉬랑 별을 써
@p	아니군
@p	그거 주석(?)
@김젼	|- 는
@김젼	많이 쓰잖아요
@p	그런가
@김젼	고등학교떄에도 봤는데
@p	난 못 봤어
@김젼	뭐지
@김젼	/랑 오망성은
@p	어디 과고 따위가 감히
@p	(??)
@김젼	Inductive Definition
@김젼	귀납적인 정으
@김젼	> 나는 귀납한다 고로 전산학을 한다
@김젼	귀납법 모르면 컴퓨터공학 못해
@김젼	귀납적으로 증명하는거 얼마나 쉬워요
@김젼	으어
@김젼	프로그램이 귀납하는거야
@김젼	갈쳐줄꼐
@김젼	우선
@김젼	여러분들
@김젼	지금까지
@김젼	옷
@김젼	기몇면
@김젼	여러가지
@김젼	데이터스트럭쳐 많이 배웠겠지만
@김젼	우리가 배우는 모든 자료구조는
@김젼	귀납적으로 정의되는
@김젼	데이터 셋의 부분집합입니다.
@김젼	아닌거같은사람?
@김젼	ㅂㅂㅂ: 해쉬테이블도 귀납적으로 정의할 수 있나요?
@김젼	해쉬테이블 정의좀 해볼래요?
@김젼	모에요:?
@김젼	우선 해쉬는
@김젼	몰라도돼
@김젼	테이블은?
@김젼	테이블이 모에요
@김젼	탁자?
@김젼	(탁자 그림)
@김젼	표
@김젼	<table>
@김젼	요런게 테이블이야
@김젼	맞아요?
@김젼	이런 테이블들의 쎗이 있어요
@김젼	테이블들의 쎗
@김젼	요런 쏏을
@김젼	인덕티브하게 정의할 수 없어요?
@김젼	ㅂㅂㅂ: 잘 모르겠습니다
@김젼	오케이
@김젼	이것도 다
@김젼	인덕티브하게 정의할 수 있는
@김젼	쎗입니다
@김젼	쉬운거부터 할게요.
@김젼	링크드리스트
@김젼	자명하게 귀납적으로 정의할 수 있죠?
@김젼	순간적으로
@김젼	귀납법을 리습법으로 읽었네
@김젼	소오름
@김젼	링크드리스트
@김젼	그림 신기하게 그리시네
@김젼	링크드리스트
@김젼	베이스케이스 : 길이 0짜리 링크드리스트
@김젼	귀납적으로 대충 싸바싸바하게 잘 구현함
@김젼	l 이 링크드리스트의 원소며
@김젼	원소이면
@김젼	'뫄->l' 도 링크드리스트의 원소이다
@김젼	이런식으로 정의함
@김젼	바이너리 트리도
@김젼	귀납적으로 정의할 수 있어요
@즈눅	data Tree a = Node a | Branch (Tree a) (Tree a)
@김젼	굿
@김젼	NIL이랑
@김젼	NIL을
@김젼	베이스케이스로 놓고
@김젼	왼쪽과 오른쪽이 바이너리 트리인 노드를
@김젼	바이너리 트리로 정의
@김젼	라고 했더니
@김젼	맞다고 하셨는데
@김젼	북부유럽스타일이라고
@김젼	좀 이상하다고 하심
@p	ㅋㅋㅋㅋ
@unusd	뫄
@p	언유놈이군
@p	눈이 침침하다
@unusd	폽새끼ㄱㄴ
@unusd	군
@unusd	뫄->|
@p	와 욕한다
@김젼	나는
@김젼	아무 원소도 없는 트리도
@김젼	트리로 봐야한다는 주장이고
@김젼	교수님은
@김젼	베이스케이스를
@김젼	노드 하나를 바이너리 트리로 놓고
@김젼	귀납적인 정의를
@unusd	욕안함 ㅎㅎ
@p	ㄷㄷ
@김젼	왼쪽이 트리이고, 오른쪽이 빈 노드도 트리
@김젼	왼쪽이 비어있고 오른쪽이 트리인 노드도 트리
@김젼	왼쪽 오른쪽 둘다 트리인 노드도 트리
@김젼	로 봐야한다는 입장
@김젼	인데
@김젼	내 정의가 더 맞는듯
@김젼	ㅎㅅㅎ
@unusd	아무 원소도 없는 트리?
@김젼	네
@김젼	여러분 그래프 보셔써요?
@김젼	그래프?
@unusd	그러면
@unusd	널 밑에 널 자식들이 주루룩 달릴 수 있잖아
@unusd	그건 안되징
@김젼	ㄴㄴ
@김젼	베이스케이스가 NIL 이고
@김젼	왼쪽 오른쪽이 트리인 '노드' 만 트리
@unusd	노드는 머징
@unusd	은..
@김젼	값이 있는 원소요
@unusd	필기에 방해가 될테니
@unusd	나중에(?)
@김젼	더 말해봐염
@김젼	그래프의 집합도
@김젼	인덕티브하게 정의할 수 있어요
@김젼	제가 코딩할때엔
@김젼	NIL있는게 편해서
@김젼	그냥 NIL을 쓰는데
@김젼	지난번에 레드블랙 트리 만들때에도
@김젼	없이해봤다가
@김젼	죽을거같아서 그냥 있게했는데 (?)
@unused	그치 트리엔 NIL이 있어야하고
@unused	링크드리스트엔
@unused	head랑 tail이 따로 있어야하고
@unused	짱짱편함..
@김젼	그래프르를
@김젼	정의하는방법
@김젼	노드 하나 를 그래프로 정의
@unused	대충 정의하면
@unused	네 말은
@김젼	그래프와 연결된 노드를 그래프로 정의
@unused	tree = nil or node(value, tree, tree)라는 건가
@김젼	네
@unused	ML이 생각 안나서 대충 야매로 써도 잘 이해하겠지(?)
@unused	음
@김젼	enum Tree { NIL, Node(Tree, Tree) }
@unused	맞는 것 같네
@unused	ㅇㅋㅇㅋ
@김젼	enum Tree { NIL, Node(value, Tree, Tree) }
@김젼	인덕티브한 그래프 정의를
@김젼	잘 못들었다
@김젼	노드 하나를 그래프로 정의
@김젼	그래프와 연결된 노드를 그래프로 정의
@김젼	랑 또 하나 더있었는데
@김젼	자기자신과 연결된 노드 또한 그래프로 정의
@김젼	였던거같음
@김젼	.. 저 기호는 뭐야?
@unused	인덕티브랑 리커시브의 차이는 뭐지?
@김젼	아마 같을듯
@unused	그렇군
@김젼	사실
@김젼	이거 전 수업
@김젼	안들어서
@김젼	모름
@김젼	Nemo: 뭐냐?
@김젼	지금
@김젼	expression 귀납적으로 정의하는중
@김젼	숫자 를 expression으로 정의
@unused	뭐 expression = constant | expression operator expression
@unused	뭐 이런건가
@김젼	n 을 정수식으로 정의
@김젼	만약 E가 정수식일경우, -E 를 정수식으로 정의
@김젼	와 이거 참 신기한기호네
@김젼	원래쓰는말인가?
@김젼	E1 E2가 정수식일경우, E1+E2 를 정수식으로 정의
@김젼	et cetera
@김젼	마교수님이
@김젼	^ 를 까먹어서
@김젼	**로 쓰심
@김젼	E가 정수식일경우, (E)를 정수식으로 정의
@김젼	등등..
@unused	아
@unused	김젼이 무슨 수업을 듣는지부터 알아야겠다
@unused	PL?
@김젼	마PL
@김젼	흡족해요?
@김젼	오케이
@김젼	굿
@김젼	ㅂㅂㅂ: 왜 곱하니느없나요?
@김젼	쓱쓱
@unused	ㅋㅋㅋ
@김젼	곱하기는 없나요
@unused	ㅂㅂㅂ랑 수업들으면 꿀잼이겠군
@p	곱하니
@김젼	E -> n
@김젼	   | E + E
@김젼	   | ExE | E/E | -E
@김젼	   | E^E
@김젼	이건
@김젼	신택스.
@김젼	제대로 생긴 익스프레션을 만드는 방법을 가르쳐줌
@unused	내가 마피엘 들을때쯤에 에세이 없어져있었으면 좋겠다
@김젼	이맨틱스 (의미, 속내용, 이해)
@김젼	시맨틱스
@김젼	시맨틱스도 인덕티브한 정의를 그대로 따라갑니다
@unused	어?
@unused	재승이가 로파스들어갔구나
@김젼	네
@unused	가디언장의 이미지밖에 없었는데
@unused	조금 어색어색
@김젼	__n__ = n
@김젼	언유는 언유다
@김젼	몬소리여
@김젼	ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
@김젼	시맨틱스는
@김젼	우리가 아는 세계와
@김젼	우리가 모르는 세계를
@김젼	매핑하는것
@김젼	영어사전은
@김젼	영단어에 대한 설명이
@김젼	영어로 써져있음
@김젼	돌고 돈다
@김젼	시맨틱스는
@김젼	한영사전
@김젼	__E1 + E2__ = __E1__ + __E2__
@즈눅	머싯는 하이픈이다
@김젼	언더스코어라능
@김젼	ㅇㅅㅇ+
@즈눅	언더바
@즈눅	ㅇㅅㅇ+
@김젼	ㅇㅅㅇ+
@김젼	애들 잘잔다
@김젼	질문이쓰요?
@김젼	너무 싱겁죠?
@김젼	제가이제 기회가 되면
@김젼	또 나올떄 말씀드리겠지만
@김젼	이런 아주
@김젼	너무 나 단순한 방법으로 정의하면
@김젼	모든게 멋지게 정의가 됩니다
@김젼	이 말이 무슨뜻이냐면
@김젼	이 방식으로 만든
@김젼	임의의 식이 있으면
@김젼	이방식으로
@김젼	모든게 다 우리가 알고있는 세계로 딱 내려와
@김젼	마자요?
@김젼	맞죠?
@김젼	퍽퍽
@김젼	그래서
@김젼	프로그래밍을 하다보면
@김젼	수학하던사람이 생각하지 못하던
@김젼	기기묘묘한 현상이 일어납니다
@김젼	미처 생각못했을까?
@김젼	하여간.
@김젼	쉽죠?
@김젼	유치해요
@김젼	유치해
@김젼	훗
@김젼	ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
@김젼	마피엘
@김젼	상형문자 보는거같음
@김젼	인덕티브한 정의를
@김젼	인덕션 안쓰고 하면
@김젼	finite 해진다.
@김젼	이러한 셋을
@김젼	Enumaration이라고 한다
@김젼	*Enumeration
@김젼	예를들어
@김젼	칼라 의 셋을 만든다고 해보자
@김젼	Color = { red, white, ... , black }
@김젼	이뉴머레이션임
@김젼	또한,
@김젼	베이스케이스가 없는 셋도 있음
@김젼	그것을 만족하는
@김젼	가장 작은 셋은
@김젼	공집합임.
@unused	empty set
@김젼	Abstract Syntax
@김젼	- 문장을 만드는 방법
@김젼	- 프로램을 만드는 방법
@김젼	(그대로 썼음)
@김젼	여러분
@김젼	- 5 / 2 + 3 ^ 5
@김젼	이거 보면
@김젼	불편하죠?
@김젼	나: 네
@김젼	왜불편해?
@김젼	우선순위떄문에요
@김젼	사실 우선순위때문에 편한거야
@김젼	괄호를 생략하고
@김젼	쓱쓱 써도 되니까
@김젼	다만 내가
@김젼	일반적으로 쓰지 않는 우선순위로 + / ^ 를 정의했지?
@p	결과가 -1인가
@김젼	(지금 binary +, x, unary -, / 순서대로 우선순위가 낮아짐)
@김젼	-((5/(2+3))^5)
@p	ㄷㄷ
@김젼	이걸
@p	맞네
@김젼	익스프레션을
@김젼	바이너리 트리로
@p	(?)
@김젼	만들어보자
@김젼	- 5 / 2 + 3 ^ 5 의 AST를 그리셨음
@김젼	자
@김젼	혼동이 없죠? 이렇게 쓰니까.
@김젼	이 왼쪽 트리가
@김젼	오른쪽 규칙을 가지고
@김젼	생각한
@김젼	정규식이야.
@김젼	이 왼쪽의 AST가
@김젼	내가 진짜 의미하는 바이고
@김젼	여러분들에게 전달하고자 하는
@김젼	의도이고
@김젼	이것을 한줄로 쓴것이
@김젼	- 5 / 2 + 3 ^ 5
@김젼	라는 코드야
@김젼	내가
@김젼	괄호를 매번 쓰기 싫으니까
@김젼	우선순위라는게 있어요
@김젼	외워둬요
@김젼	우선순위가 깨지는 경우가 있다면
@김젼	그떄에만 괄호를 치는걸로.
@김젼	괄호도 연산자로 보면
@김젼	E -> n
@김젼	   | (E)
@김젼	   | E + E
@김젼	   | E x E
@김젼	   | -E
@김젼	   | E / E
@김젼	음..
@김젼	5 + 2 * 3
@김젼	1. 21
@김젼	2. 11
@김젼	1차원의 식을
@김젼	AST로 만드는 과정
@김젼	파싱.
@김젼	이것이 스텝 0.
@김젼	파싱을 할때
@김젼	gramma rule이라는걸 써요
@김젼	E -> n
@김젼	   | ~~~
@김젼	이 정의는
@김젼	만드는 사람 용
@김젼	문법을 만드는사람이 쓰는 문법이고
@김젼	gramma rule은
@김젼	1차원의 식을 2차원의 AST로 파싱할떄 쓰는 문법
@김젼	듣는사람용
@김젼	학생 어디가요?
@김젼	최성호: 화장실이요
@김젼	그래요
@김젼	파싱을 하는 소프트를
@김젼	파서라고 해요
@disjukr_talk	? 텍스트 트위치 같은 느낌인가요 ㅋㅋㅋㅋ
@disjukr_talk	재밌네
@김젼	수업 필기에염
@김젼	이거시 바로 IRC대학
@김젼	그래머 룰은
@김젼	훨씬 복잡해요
@김젼	앞에부터 읽어나갈떄
@김젼	뒤를 더 읽을지 말지
@김젼	이런게 필요해요
@김젼	여러분들이 컴파일러를 들으면
@김젼	어떻게 그래머 룰을 만드는지
@김젼	어떻게 식에서 AST로 만드는지를
@김젼	강의해요 근데
@김젼	70년대 80년대까지는
@김젼	이걸 엄청나게 빡세게 가르쳤는데
@김젼	요즘은 이 파서를 자동으로 만들어요
@김젼	파서를 자동으로 만드는 툴이 있어요
@김젼	그 툴 쓸때 쓰는 룰이 있는데 이거(귀납적 정의)보다 훨씬 복잡합니다.
@김젼	프로그램 하면
@김젼	이 만든사람이 정의한 룰만 있으면 끝이에요
@김젼	그래서 이
@김젼	만드는사람이 쓰는 신택스
@김젼	E -> n
@김젼	   | E+E
@김젼	~~
@김젼	이걸 Abstract Syntax라고 합니다.
@김젼	그리고
@김젼	파싱할떄 쓰는
@김젼	그래머
@김젼	이거를
@김젼	Concrete Syntax라고 합니다
@김젼	.현실의, 실재하는(real); 현실에 근거한, 실제적인; 구체적인,
@김젼	쉅
@김젼	일찍끝난당
@김젼	unused: 아까 그거
@김젼	질문할까여
@김젼	여러분
@김젼	이거 표현하는거 아세요?
@김젼	Kn : Z -> E
@김젼	타이
@김젼	타입
@김젼	Kn 이건 여러분이 정의할 프로시저고
@김젼	:: 가 타입이라는 기호고
@김젼	Z -> E 가 입력이 어떻고 출력이 어떤지.
@김젼	이거 노테이션일 뿐이에요
@김젼	어려울거 아무것도 없어
@김젼	여러분 수학시간때 이런거 써봤죠?
@김젼	f : A -> B
@김젼	x 삼지창 {1, 2, 3}
@김젼	y 삼지창 A U B
@김젼	z 삼지창 A x B
@김젼	합집합 표시에요
@김젼	덧셈기호로 쓰기도 해요
@김젼	A + B
@김젼	대개 이거를
@김젼	이렇게 표현하기도 해요
@김젼	B^A
@김젼	처음보죠?
@김젼	이건 못봤을거야
@김젼	A -> B 이걸 B^A 이렇게 표현
@김젼	이렇게 표현하기도 해요
@김젼	괴팍한사람들은 이렇게 쓰기도 해
@p	∈
@p	자 여깄다
@p	(?)
@김젼	야호
@p	아호 코라식
@즈눅	∉
@김젼	f ∈ A -> B
@김젼	x ∈ {1, 2, 3}
@p	ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
@p	저거줄걸
@김젼	y ∈ A + B (합)
@김젼	z ∈ A x B (곱)
@김젼	f ∈ A -> B 이게 멱일거야 아마
@김젼	나도 헷갈리는데
@김젼	곱이 뭐냐
@김젼	순서쌍들의 집합이에요
@김젼	A x B = {(a, b) | a ∈ A, b ∈ B}
@김젼	zm
@김젼	크
@김젼	타임머신 필기
@김젼	교수님이 쓰는거보다 먼저 응?
@김젼	예지력 1 감소
@김젼	(a, b)가 아니라
@김젼	<a, b>로 쓰심
@김젼	C 에서 이걸 만드는 방법은
@김젼	이와 같습니다
@김젼	struct pair {
@김젼	  A a;
@김젼	  B b;
@김젼	};
@김젼	struct pair x;
@김젼	이렇게 하면 만들 수 있어요
@김젼	Product Type
@김젼	슬기형이
@김젼	N개월 전부터
@김젼	뿌린 떡밥이
@김젼	회수되었다
@김젼	오캐믈에서는
@김젼	이러케하면 돼
@김젼	스칼라에서도 간단해요
@김젼	(1, "a")
@김젼	요러면 끝이야
@김젼	왜 여러분들이
@김젼	실습할떄 C 하면 안되는지 알겠지?
@김젼	러스트로 해야돼
@김젼	전할수이쓰요
@김젼	그런사람은 해도돼
@unused	와
@김젼	하지만 앞으로 펼쳐질 기기묘묘한 숙제를 할때엔 고생이 심할거야
@즈눅	ㅘ
@김젼	러스트로 해도되나
@김젼	방금
@김젼	교수님께서 분명히
@김젼	할수있는사람은
@김젼	해도 된다고 하셨는데
@unused	4년전인가에 escamp 한답시고 짰던 생명게임 C++ 코드 존나 개똥같네 진짜 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
@김젼	f ∈ A -> B
@김젼	A -> B 이건
@unused	이래놓고 내가 C++를 쓰니 뭐니 얘기하고 다녔다니 참 부끄럽당
@김젼	정의역이 A이고, 공역이 B인 모든 함수들의 집합을
@김젼	A -> B
@김젼	이렇게 표현해요
@김젼	4년전이면
@김젼	2011 년이라서
@김젼	개똥같을수밖에 없을거같은데 (?)
@p	unused: 보여줘
@unused	으
@unused	안돼
@unused	일단
@p	안 되긴 뭐가 안 돼
@p	내놔
@p	(?)
@unused	vector<char> 대신 new char[bufferSize] 같은 코드를 짰음
@unused	난 틀려먹었어...
@김젼	뉴챠
@김젼	https://github.com/simnalamburt/EasyD3D
@김젼	2년전에 짠 코드
@unused	문자열 돌려주는데 리턴이 const string이야...
@김젼	누가 리뷰점
@p	머리박고 죽으세요
@unused	shiffa...
@p	너 그런 코드 짜면 뭐 되는지 알아? 인간 쓰레기 되는거야
@p	(??)
@김젼	A -> B
@김젼	헐
@김젼	const string
@김젼	리턴하는게 뭐 어때서요
@김젼	const 벗기고 쓰면 되죠
@p	내가 쓰레기라고 ㅇㅇ
@김젼	박상어 고유명사인 데이터는요
@김젼	일반명사로
@p	괜찮아 그래도 인간이잖아
@김젼	써머리해요
@김젼	남자 타입의
@김젼	원소다
@김젼	A ->
@p	여기는 인간도 없어
@unused	http://pastebin.com/x8kJjBri
@김젼	A -> B
@unused	코드의 일부
@김젼	이건 타입이에요
@unused	헤더파일 하나만 가져옴
@p	winsock2.h ..!
@김젼	explicit 오랫만에 본다
@p	뭐야 const없네
@김젼	역시
@p	const 어디다 팔아먹었어
@김젼	쓸못 C++ (?)
@unused	bool opened() const;
@p	portno라니
@p	portnoy
@김젼	맠포토
@김젼	집에가고시퍼
@김젼	보내줘
@unused	http://pastebin.com/0ZjdpnG5
@unused	헤더 하나 더
@unused	여러분의 까임을 환영합니다
@unused	까임이 아니지
@unused	여러분의 블레임을 환영합니다
@김젼	오늘은 여기까지
```
